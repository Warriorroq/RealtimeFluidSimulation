 -- ComputeHelper.cs --
using UnityEngine;
using UnityEngine.Experimental.Rendering;
using System.Collections.Generic;
#if UNITY_EDITOR
using UnityEditor;
#endif
using System.Linq;

namespace Project.Helpers
{
	public enum DepthMode
	{
		None = 0,
		Depth16 = 16,
		Depth24 = 24
	}
	
	public static class ComputeHelper
	{
#region Constants
		public const FilterMode defaultFilterMode = FilterMode.Bilinear;
		public const GraphicsFormat defaultGraphicsFormat = GraphicsFormat.R32G32B32A32_SFloat;
		private static readonly uint[] ARGS_BUFFER_ARRAY = new uint[5];
#endregion

#region Thread Groups
		public static void Dispatch(ComputeShader cs, Vector3Int numIterations, int kernelIndex = 0)
		{
			Dispatch(cs, numIterations.x, numIterations.y, numIterations.z, kernelIndex);
		}

		/// Convenience method for dispatching a compute shader.
		/// It calculates the number of thread groups based on the number of iterations needed.
		public static void Dispatch(ComputeShader cs, int numIterationsX, int numIterationsY = 1, int numIterationsZ = 1, int kernelIndex = 0)
		{
			Vector3Int sizes = GetThreadGroupSizes(cs, kernelIndex);
			Vector3Int groups = new Vector3Int(
				GetNumGroups(numIterationsX, sizes.x),
				GetNumGroups(numIterationsY, sizes.y),
				GetNumGroups(numIterationsZ, sizes.z));

			cs.Dispatch(kernelIndex, groups.x, groups.y, groups.z);
		}

		public static int CalculateThreadGroupCount1D(ComputeShader cs, int numIterationsX, int kernelIndex = 0)
		{
			Vector3Int sizes = GetThreadGroupSizes(cs, kernelIndex);
			return GetNumGroups(numIterationsX, sizes.x);
		}
#endregion

#region Buffer Helpers
		public static int GetStride<T>()
		{
			return System.Runtime.InteropServices.Marshal.SizeOf(typeof(T));
		}

		public static ComputeBuffer CreateAppendBuffer<T>(int size = 1)
		{
			int stride = GetStride<T>();
			ComputeBuffer buffer = new ComputeBuffer(size, stride, ComputeBufferType.Append);
			buffer.SetCounterValue(0);
			return buffer;
		}


		public static void CreateAppendBuffer<T>(ref ComputeBuffer buffer, int count)
		{
			int stride = GetStride<T>();
			bool createNewBuffer = buffer == null || !buffer.IsValid() || buffer.count != count || buffer.stride != stride;
			if (createNewBuffer)
			{
				Release(buffer);
				buffer = new ComputeBuffer(count, stride, ComputeBufferType.Append);
			}

			buffer.SetCounterValue(0);
		}

		public static bool CreateStructuredBuffer<T>(ref ComputeBuffer buffer, int count)
		{
			int stride = GetStride<T>();
			bool createNewBuffer = buffer == null || !buffer.IsValid() || buffer.count != count || buffer.stride != stride;
			if (createNewBuffer)
			{
				Release(buffer);
				buffer = new ComputeBuffer(count, stride);
				return true;
			}

			return false;
		}


		public static ComputeBuffer CreateStructuredBuffer<T>(T[] data)
		{
			var buffer = new ComputeBuffer(data.Length, GetStride<T>());
			buffer.SetData(data);
			return buffer;
		}

		public static ComputeBuffer CreateStructuredBuffer<T>(List<T> data) where T : struct
		{
			var buffer = new ComputeBuffer(data.Count, GetStride<T>());
			buffer.SetData(data);

			return buffer;
		}

		public static void CreateStructuredBuffer<T>(ref ComputeBuffer buffer, List<T> data) where T : struct
		{
			int stride = GetStride<T>();
			bool createNewBuffer = buffer == null || !buffer.IsValid() || buffer.count != data.Count || buffer.stride != stride;
			if (createNewBuffer)
			{
				Release(buffer);
				buffer = new ComputeBuffer(data.Count, stride);
			}

			buffer.SetData(data);
			// Debug.Log(buffer.IsValid());
		}

		public static ComputeBuffer CreateStructuredBuffer<T>(int count)
		{
			return new ComputeBuffer(count, GetStride<T>());
		}

		public static void CreateStructuredBuffer<T>(ref ComputeBuffer buffer, T[] data)
		{
			CreateStructuredBuffer<T>(ref buffer, data.Length);
			buffer.SetData(data);
		}

		public static void SetBuffer(ComputeShader compute, ComputeBuffer buffer, string id, params int[] kernels)
		{
			for (int i = 0; i < kernels.Length; i++)
				compute.SetBuffer(kernels[i], id, buffer);
		}

		public static void SetBuffers(ComputeShader cs, int kernel, Dictionary<ComputeBuffer, string> nameLookup, params ComputeBuffer[] buffers)
		{
			foreach (ComputeBuffer buffer in buffers)
				cs.SetBuffer(kernel, nameLookup[buffer], buffer);
		}

		public static ComputeBuffer CreateAndSetBuffer<T>(T[] data, ComputeShader cs, string nameID, int kernelIndex = 0)
		{
			ComputeBuffer buffer = null;
			CreateAndSetBuffer<T>(ref buffer, data, cs, nameID, kernelIndex);
			return buffer;
		}

		public static void CreateAndSetBuffer<T>(ref ComputeBuffer buffer, T[] data, ComputeShader cs, string nameID, int kernelIndex = 0)
		{
			CreateStructuredBuffer<T>(ref buffer, data.Length);
			buffer.SetData(data);
			cs.SetBuffer(kernelIndex, nameID, buffer);
		}

		public static ComputeBuffer CreateAndSetBuffer<T>(int length, ComputeShader cs, string nameID, int kernelIndex = 0)
		{
			ComputeBuffer buffer = null;
			CreateAndSetBuffer<T>(ref buffer, length, cs, nameID, kernelIndex);
			return buffer;
		}

		public static void CreateAndSetBuffer<T>(ref ComputeBuffer buffer, int length, ComputeShader cs, string nameID, int kernelIndex = 0)
		{
			CreateStructuredBuffer<T>(ref buffer, length);
			cs.SetBuffer(kernelIndex, nameID, buffer);
		}


		/// Releases supplied buffer/s if not null
		public static void Release(params ComputeBuffer[] buffers)
		{
			foreach (var b in buffers)
			{
				b?.Release();
			}
		}

		/// Releases supplied render textures/s if not null
		public static void Release(params RenderTexture[] textures)
		{
			foreach (var t in textures)
			{
				t?.Release();
			}
		}
#endregion

#region RenderTexture helpers
		public static Vector3Int GetThreadGroupSizes(ComputeShader compute, int kernelIndex = 0)
		{
			uint x, y, z;
			compute.GetKernelThreadGroupSizes(kernelIndex, out x, out y, out z);
			return new Vector3Int((int)x, (int)y, (int)z);
		}


		public static RenderTexture CreateRenderTexture(RenderTexture template)
		{
			RenderTexture renderTexture = null;
			CreateRenderTexture(ref renderTexture, template);
			return renderTexture;
		}

		public static RenderTexture CreateRenderTexture(int width, int height, FilterMode filterMode, GraphicsFormat format, string name = "Unnamed", DepthMode depthMode = DepthMode.None, bool useMipMaps = false)
		{
			RenderTexture texture = new RenderTexture(width, height, (int)depthMode);
			texture.graphicsFormat = format;
			texture.enableRandomWrite = true;
			texture.autoGenerateMips = false;
			texture.useMipMap = useMipMaps;
			texture.Create();

			texture.name = name;
			texture.wrapMode = TextureWrapMode.Clamp;
			texture.filterMode = filterMode;
			return texture;
		}

		public static void CreateRenderTexture(ref RenderTexture texture, RenderTexture template)
		{
			if (texture != null)
			{
				texture.Release();
			}

			texture = new RenderTexture(template.descriptor);
			texture.enableRandomWrite = true;
			texture.Create();
		}

		public static void CreateRenderTexture(ref RenderTexture texture, int width, int height)
		{
			CreateRenderTexture(ref texture, width, height, defaultFilterMode, defaultGraphicsFormat);
		}

		public static RenderTexture CreateRenderTexture(int width, int height)
		{
			return CreateRenderTexture(width, height, defaultFilterMode, defaultGraphicsFormat);
		}


		public static bool CreateRenderTexture(ref RenderTexture texture, int width, int height, FilterMode filterMode, GraphicsFormat format, string name = "Unnamed", DepthMode depthMode = DepthMode.None, bool useMipMaps = false)
		{
			if (texture == null || !texture.IsCreated() || texture.width != width || texture.height != height || texture.graphicsFormat != format || texture.depth != (int)depthMode || texture.useMipMap != useMipMaps)
			{
				if (texture != null)
				{
					texture.Release();
				}

				texture = CreateRenderTexture(width, height, filterMode, format, name, depthMode, useMipMaps);
				return true;
			}
			else
			{
				SetRenderTextureProperties(texture, name, filterMode);
			}

			return false;
		}


		public static void CreateRenderTexture3D(ref RenderTexture texture, RenderTexture template)
		{
			CreateRenderTexture(ref texture, template);
		}

		public static void CreateRenderTexture3D(ref RenderTexture texture, int size, GraphicsFormat format, TextureWrapMode wrapMode = TextureWrapMode.Repeat, string name = "Untitled", bool mipmaps = false)
		{
			CreateRenderTexture3D(ref texture, size, size, size, format, wrapMode, name, mipmaps);
		}

		public static void CreateRenderTexture3D(ref RenderTexture texture, int width, int height, int depth, GraphicsFormat format, TextureWrapMode wrapMode = TextureWrapMode.Repeat, string name = "Untitled", bool mipmaps = false)
		{
			if (texture == null || !texture.IsCreated() || texture.width != width || texture.height != height || texture.volumeDepth != depth || texture.graphicsFormat != format)
			{
				//Debug.Log ("Create tex: update noise: " + updateNoise);
				if (texture != null)
				{
					texture.Release();
				}

				const int numBitsInDepthBuffer = 0;
				texture = new RenderTexture(width, height, numBitsInDepthBuffer);
				texture.graphicsFormat = format;
				texture.volumeDepth = depth;
				texture.enableRandomWrite = true;
				texture.dimension = UnityEngine.Rendering.TextureDimension.Tex3D;
				texture.useMipMap = mipmaps;
				texture.autoGenerateMips = false;
				texture.Create();
			}

			SetRenderTextureProperties(texture, name, FilterMode.Bilinear, wrapMode);
		}
#endregion

#region Argument Buffers
		// Create args buffer for instanced indirect rendering
		public static ComputeBuffer CreateArgsBuffer(Mesh mesh, int numInstances)
		{
			const int stride = sizeof(uint);
			const int numArgs = 5;

			const int subMeshIndex = 0;
			uint[] args = new uint[numArgs];
			args[0] = (uint)mesh.GetIndexCount(subMeshIndex);
			args[1] = (uint)numInstances;
			args[2] = (uint)mesh.GetIndexStart(subMeshIndex);
			args[3] = (uint)mesh.GetBaseVertex(subMeshIndex);
			args[4] = 0; // offset

			ComputeBuffer argsBuffer = new ComputeBuffer(numArgs, stride, ComputeBufferType.IndirectArguments);
			argsBuffer.SetData(args);
			return argsBuffer;
		}

		public static void CreateArgsBuffer(ref ComputeBuffer buffer, uint[] args)
		{
			const int stride = sizeof(uint);
			const int numArgs = 5;
			if (buffer == null || buffer.stride != stride || buffer.count != numArgs || !buffer.IsValid())
			{
				buffer = new ComputeBuffer(numArgs, stride, ComputeBufferType.IndirectArguments);
			}

			buffer.SetData(args);
		}

		private static readonly uint[] SINGLE_INSTANCE_RENDER_ARGS =
		{
			0, // Index count (to be set)
			1, // instance count
			0, // submesh index
			0, // base vertex
			0, // offset
		};

		public static void CreateArgsBuffer(ref ComputeBuffer buffer, ComputeBuffer appendBuffer)
		{
			const int stride = sizeof(uint);
			if (buffer == null || buffer.stride != stride || buffer.count != SINGLE_INSTANCE_RENDER_ARGS.Length || !buffer.IsValid())
			{
				buffer = new ComputeBuffer(SINGLE_INSTANCE_RENDER_ARGS.Length, stride, ComputeBufferType.IndirectArguments);
			}

			buffer.SetData(SINGLE_INSTANCE_RENDER_ARGS);
			ComputeBuffer.CopyCount(appendBuffer, buffer, dstOffsetBytes: 0);
		}
		
		public static void CreateArgsBuffer(ref ComputeBuffer argsBuffer, Mesh mesh, int numInstances)
		{
			const int stride = sizeof(uint);
			const int numArgs = 5;
			const int subMeshIndex = 0;

			bool createNewBuffer = argsBuffer == null || !argsBuffer.IsValid() || argsBuffer.count != ARGS_BUFFER_ARRAY.Length || argsBuffer.stride != stride;
			if (createNewBuffer)
			{
				Release(argsBuffer);
				argsBuffer = new ComputeBuffer(numArgs, stride, ComputeBufferType.IndirectArguments);
			}

			lock (ARGS_BUFFER_ARRAY)
			{
				ARGS_BUFFER_ARRAY[0] = (uint)mesh.GetIndexCount(subMeshIndex);
				ARGS_BUFFER_ARRAY[1] = (uint)numInstances;
				ARGS_BUFFER_ARRAY[2] = (uint)mesh.GetIndexStart(subMeshIndex);
				ARGS_BUFFER_ARRAY[3] = (uint)mesh.GetBaseVertex(subMeshIndex);
				ARGS_BUFFER_ARRAY[4] = 0; // offset
				
				argsBuffer.SetData(ARGS_BUFFER_ARRAY);
			}
		}

		// Create args buffer for instanced indirect rendering (number of instances comes from size of append buffer)
		public static ComputeBuffer CreateArgsBuffer(Mesh mesh, ComputeBuffer appendBuffer) =>
			CopyCountThenReturn(CreateArgsBuffer(mesh, 0), appendBuffer);

		private static ComputeBuffer CopyCountThenReturn(ComputeBuffer destination, ComputeBuffer source)
		{
			ComputeBuffer.CopyCount(source, destination, sizeof(uint));
			return destination;
		}

		// Read number of elements in append buffer
		public static int ReadAppendBufferLength(ComputeBuffer appendBuffer)
		{
			ComputeBuffer countBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);
			ComputeBuffer.CopyCount(appendBuffer, countBuffer, 0);

			int[] data = new int[1];
			countBuffer.GetData(data);
			Release(countBuffer);
			return data[0];
		}

		public static void SetTexture(ComputeShader compute, Texture texture, string name, params int[] kernels)
		{
			for (int i = 0; i < kernels.Length; i++)
			{
				compute.SetTexture(kernels[i], name, texture);
			}
		}

		// Set all values from settings object on the shader. Note, variable names must be an exact match in the shader.
		// Settings object can be any class/struct containing vectors/ints/floats/bools
		public static void SetParams(System.Object settings, ComputeShader shader, string variableNamePrefix = "", string variableNameSuffix = "")
		{
			var fields = settings.GetType().GetFields();
			foreach (var field in fields)
			{
				var fieldType = field.FieldType;
				string shaderVariableName = variableNamePrefix + field.Name + variableNameSuffix;

				if (fieldType == typeof(UnityEngine.Vector4) || fieldType == typeof(Vector3) || fieldType == typeof(Vector2))
				{
					shader.SetVector(shaderVariableName, (Vector4)field.GetValue(settings));
				}
				else if (fieldType == typeof(int))
				{
					shader.SetInt(shaderVariableName, (int)field.GetValue(settings));
				}
				else if (fieldType == typeof(float))
				{
					shader.SetFloat(shaderVariableName, (float)field.GetValue(settings));
				}
				else if (fieldType == typeof(bool))
				{
					shader.SetBool(shaderVariableName, (bool)field.GetValue(settings));
				}
				else
				{
					Debug.Log($"Type {fieldType} not implemented");
				}
			}
		}


		public static float[] PackFloats(params float[] values)
		{
			float[] packed = new float[values.Length * 4];
			for (int i = 0; i < values.Length; i++)
			{
				packed[i * 4] = values[i];
			}

			return packed;
		}

		// Load compute shader by name. Prioritises Resources folder, but includes fallbacks for assets located elsewhere.
		public static void LoadComputeShader(ref ComputeShader shader, string name)
		{
			if (shader == null)
			{
				shader = LoadComputeShader(name);
			}
		}
		
		// Load compute shader by name. Prioritises Resources folder, but includes fallbacks for assets located elsewhere.
		public static ComputeShader LoadComputeShader(string name)
		{
			// Remove any extension that might have been supplied (e.g., ".compute")
			string cleanName = System.IO.Path.GetFileNameWithoutExtension(name);

			// 1) Try standard Resources lookup first (original behaviour)
			ComputeShader shader = Resources.Load<ComputeShader>(cleanName);

#if UNITY_EDITOR
			// 2) If not found, attempt to locate the asset anywhere in the project via AssetDatabase (Editor-only)
			if (shader == null)
			{
				string[] guids = UnityEditor.AssetDatabase.FindAssets($"{cleanName} t:ComputeShader");
				if (guids != null && guids.Length > 0)
				{
					string path = UnityEditor.AssetDatabase.GUIDToAssetPath(guids[0]);
					shader        = UnityEditor.AssetDatabase.LoadAssetAtPath<ComputeShader>(path);
				}
			}
#endif

			// 3) Fallback: search any already-loaded compute shaders in memory (works in builds)
			if (shader == null)
			{
				shader = Resources.FindObjectsOfTypeAll<ComputeShader>().FirstOrDefault(s => s.name == cleanName);
			}

			if (shader == null)
			{
				Debug.LogError($"Compute shader '{cleanName}' could not be found. Ensure it is placed in a Resources folder or included in the build.");
			}

			return shader;
		}

		// Get data (cpu readback) from buffer
		public static T[] ReadbackData<T>(ComputeBuffer buffer)
		{
			T[] data = new T[buffer.count];
			buffer.GetData(data);
			return data;
		}
#endregion

#region Misc
        // Helper method to calculate thread group count (ceil division)
        private static int GetNumGroups(int iterations, int size) => Mathf.CeilToInt(iterations / (float)size);

        // Helper method to configure basic RenderTexture properties
        private static void SetRenderTextureProperties(RenderTexture tex, string label, FilterMode mode, TextureWrapMode wrap = TextureWrapMode.Clamp)
        {
            tex.name       = label;
            tex.wrapMode   = wrap;
            tex.filterMode = mode;
        }
#endregion
	}
}
------------------------------

 -- CountArrange.compute --
#pragma kernel initBuffers
#pragma kernel tallyKeys
#pragma kernel scatterSortedData
#pragma kernel copyToSource

RWStructuredBuffer<uint> itemBuffer;
RWStructuredBuffer<uint> keyBuffer;
RWStructuredBuffer<uint> sortedItemBuffer;
RWStructuredBuffer<uint> sortedKeyBuffer;

RWStructuredBuffer<uint> prefixSum;
uint elementCount;

static const int GROUP_SIZE = 256;

// Initialise count and item mapping for a single element
void InitializeEntry(uint index)
{
    prefixSum[index] = 0;
    itemBuffer[index] = index;
}

// Returns the key for an input element
uint FetchKey(uint index)
{
    return keyBuffer[index];
}

// Writes one element into the sorted buffers
void Scatter(uint dst, uint src, uint key)
{
    sortedItemBuffer[dst] = itemBuffer[src];
    sortedKeyBuffer[dst] = key;
}

[numthreads(GROUP_SIZE, 1, 1)]
void initBuffers(uint3 gid : SV_DispatchThreadID)
{
    if (gid.x >= elementCount) return;
    InitializeEntry(gid.x);
}

[numthreads(GROUP_SIZE, 1, 1)]
void tallyKeys(uint3 gid : SV_DispatchThreadID)
{
    if (gid.x >= elementCount) return;
    uint k = FetchKey(gid.x);
    InterlockedAdd(prefixSum[k], 1);
}

[numthreads(GROUP_SIZE, 1, 1)]
void scatterSortedData(uint3 gid : SV_DispatchThreadID)
{
    if (gid.x >= elementCount) return;

    uint k = FetchKey(gid.x);
    uint dstIndex;
    InterlockedAdd(prefixSum[k], 1, dstIndex);

    Scatter(dstIndex, gid.x, k);
}

[numthreads(GROUP_SIZE, 1, 1)]
void copyToSource(uint3 gid : SV_DispatchThreadID)
{
    if (gid.x >= elementCount) return;

    itemBuffer[gid.x] = sortedItemBuffer[gid.x];
    keyBuffer[gid.x] = sortedKeyBuffer[gid.x];
}

------------------------------

 -- GPUCountSort.cs --
using UnityEngine;
using Project.Helpers;

namespace Project.GPUSorting
{
    public class GPUCountSort
    {
        // Shader property IDs
        private static readonly int ID_ITEM_BUFFER = Shader.PropertyToID("itemBuffer");
        private static readonly int ID_KEY_BUFFER = Shader.PropertyToID("keyBuffer");
        private static readonly int ID_SORTED_ITEM_BUFFER = Shader.PropertyToID("sortedItemBuffer");
        private static readonly int ID_SORTED_KEY_BUFFER = Shader.PropertyToID("sortedKeyBuffer");
        private static readonly int ID_PREFIX_SUM = Shader.PropertyToID("prefixSum");
        private static readonly int ID_ELEMENT_COUNT = Shader.PropertyToID("elementCount");

        // Kernel indices (order must match compute shader listing)
        private const int INIT_BUFFERS_KERNEL = 0;
        private const int TALLY_KEYS_KERNEL = 1;
        private const int SCATTER_KERNEL = 2;
        private const int COPY_TO_SOURCE_KERNEL = 3;

        private readonly ScanStride _scan = new();
        private readonly ComputeShader _cs = ComputeHelper.LoadComputeShader("CountArrange");

        private ComputeBuffer _sortedItemBuffer;
        private ComputeBuffer _sortedKeyBuffer;
        private ComputeBuffer _prefixSumBuffer;

        /// <summary>
        /// Sorts an index buffer using a corresponding key buffer.
        /// </summary>
        public void Run(ComputeBuffer itemsBuffer, ComputeBuffer keysBuffer, uint maxKeyValue)
        {
            int count = itemsBuffer.count;

            PrepareBuffers(count, maxKeyValue);
            BindUserBuffers(itemsBuffer, keysBuffer, count);

            Dispatch(count);
        }

        private void PrepareBuffers(int count, uint maxKeyValue)
        {
            if (ComputeHelper.CreateStructuredBuffer<uint>(ref _sortedItemBuffer, count))
            {
                _cs.SetBuffer(SCATTER_KERNEL, ID_SORTED_ITEM_BUFFER, _sortedItemBuffer);
                _cs.SetBuffer(COPY_TO_SOURCE_KERNEL, ID_SORTED_ITEM_BUFFER, _sortedItemBuffer);
            }

            if (ComputeHelper.CreateStructuredBuffer<uint>(ref _sortedKeyBuffer, count))
            {
                _cs.SetBuffer(SCATTER_KERNEL, ID_SORTED_KEY_BUFFER, _sortedKeyBuffer);
                _cs.SetBuffer(COPY_TO_SOURCE_KERNEL, ID_SORTED_KEY_BUFFER, _sortedKeyBuffer);
            }

            if (ComputeHelper.CreateStructuredBuffer<uint>(ref _prefixSumBuffer, (int)maxKeyValue + 1))
            {
                _cs.SetBuffer(INIT_BUFFERS_KERNEL, ID_PREFIX_SUM, _prefixSumBuffer);
                _cs.SetBuffer(TALLY_KEYS_KERNEL, ID_PREFIX_SUM, _prefixSumBuffer);
                _cs.SetBuffer(SCATTER_KERNEL, ID_PREFIX_SUM, _prefixSumBuffer);
            }
        }

        private void BindUserBuffers(ComputeBuffer itemsBuffer, ComputeBuffer keysBuffer, int count)
        {
            _cs.SetBuffer(INIT_BUFFERS_KERNEL, ID_ITEM_BUFFER, itemsBuffer);
            _cs.SetBuffer(SCATTER_KERNEL, ID_ITEM_BUFFER, itemsBuffer);
            _cs.SetBuffer(COPY_TO_SOURCE_KERNEL, ID_ITEM_BUFFER, itemsBuffer);

            _cs.SetBuffer(TALLY_KEYS_KERNEL, ID_KEY_BUFFER, keysBuffer);
            _cs.SetBuffer(SCATTER_KERNEL, ID_KEY_BUFFER, keysBuffer);
            _cs.SetBuffer(COPY_TO_SOURCE_KERNEL, ID_KEY_BUFFER, keysBuffer);

            _cs.SetInt(ID_ELEMENT_COUNT, count);
        }

        private void Dispatch(int count)
        {
            ComputeHelper.Dispatch(_cs, count, kernelIndex: INIT_BUFFERS_KERNEL);
            ComputeHelper.Dispatch(_cs, count, kernelIndex: TALLY_KEYS_KERNEL);

            _scan.Run(_prefixSumBuffer);

            ComputeHelper.Dispatch(_cs, count, kernelIndex: SCATTER_KERNEL);
            ComputeHelper.Dispatch(_cs, count, kernelIndex: COPY_TO_SOURCE_KERNEL);
        }

        public void Release()
        {
            ComputeHelper.Release(_sortedItemBuffer, _sortedKeyBuffer, _prefixSumBuffer);
            _scan.Release();
        }
    }
}
------------------------------

 -- MeshBuilder.cs --
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Project.Helpers
{
    /// <summary>
    /// Utility class for generating simple procedural meshes such as quads and geodesic spheres.
    /// </summary>
    public static class MeshBuilder
    {
        #region Quad Mesh

        /// <summary>
        /// Generates a 1×1 quad centred at the origin on the XY-plane.
        /// </summary>
        public static Mesh GenerateQuadMesh()
        {
            // Clockwise winding order when facing the +Z axis (Unity default).
            int[] indices = { 0, 1, 2, 2, 1, 3 };

            Vector3[] vertices =
            {
                new(-0.5f,  0.5f, 0f),
                new( 0.5f,  0.5f, 0f),
                new(-0.5f, -0.5f, 0f),
                new( 0.5f, -0.5f, 0f)
            };

            Vector2[] uvs =
            {
                new(0f, 1f),
                new(1f, 1f),
                new(0f, 0f),
                new(1f, 0f)
            };

            Mesh mesh = new()
            {
                vertices = vertices,
                uv = uvs
            };
            mesh.SetTriangles(indices, submesh: 0, calculateBounds: true);
            return mesh;
        }

        #endregion

        #region Sphere Mesh

        // Topology description of a unit octahedron. The octahedron is the base
        // polyhedron for the geodesic sphere subdivision.
        private static readonly int[] VertexPairs =
        {
            // Twelve edges represented by their start/end vertex indices.
            0,1, 0,2, 0,3, 0,4,
            1,2, 2,3, 3,4, 4,1,
            5,1, 5,2, 5,3, 5,4
        };

        private static readonly int[] EdgeTriplets =
        {
            // Eight triangular faces described by their three edge indices.
            0,1,4, 1,2,5, 2,3,6, 3,0,7,
            8,9,4, 9,10,5, 10,11,6, 11,8,7
        };

        private static readonly Vector3[] BaseVertices =
        {
            Vector3.up,
            Vector3.left,
            Vector3.back,`
            Vector3.right,
            Vector3.forward,
            Vector3.down
        };

        /// <summary>
        /// Generates a geodesic sphere mesh. <paramref name="resolution"/> is
        /// the subdivision count per edge (≥ 0).
        /// </summary>
        public static Mesh GenerateSphereMesh(int resolution)
        {
            int divisions = Mathf.Max(0, resolution);

            int vertsPerFace = ((divisions + 3) * (divisions + 3) - (divisions + 3)) / 2;
            int totalVerts  = vertsPerFace * 8 - (divisions + 2) * 12 + 6;
            int trisPerFace = (divisions + 1) * (divisions + 1);

            var vertices  = new FixedSizeList<Vector3>(totalVerts);
            var triangles = new FixedSizeList<int>(trisPerFace * 8 * 3);

            // Seed octahedron corner vertices.
            vertices.AddRange(BaseVertices);

            // Build all 12 edges with interpolated points.
            Edge[] edges = BuildEdges(divisions, vertices);

            // Construct each triangular face.
            for (int i = 0; i < EdgeTriplets.Length; i += 3)
            {
                bool reverse = (i / 3) >= 4; // Bottom hemisphere uses flipped winding.
                CreateFace(
                    edges[EdgeTriplets[i]],
                    edges[EdgeTriplets[i + 1]],
                    edges[EdgeTriplets[i + 2]],
                    divisions,
                    reverse,
                    vertices,
                    triangles);
            }

            // Assemble the mesh.
            Mesh mesh = new() { vertices = vertices.items };
            mesh.SetTriangles(triangles.items, 0, true);
            mesh.RecalculateNormals();
            return mesh;
        }

        /// <summary>
        /// Builds interpolated edge data for the geodesic sphere.
        /// </summary>
        private static Edge[] BuildEdges(int divisions, FixedSizeList<Vector3> verts)
        {
            Edge[] edges = new Edge[12];

            for (int i = 0; i < VertexPairs.Length; i += 2)
            {
                Vector3 a = verts.items[VertexPairs[i]];
                Vector3 b = verts.items[VertexPairs[i + 1]];

                int[] indices = new int[divisions + 2];
                indices[0] = VertexPairs[i];

                for (int d = 0; d < divisions; d++)
                {
                    float t = (d + 1f) / (divisions + 1f);
                    indices[d + 1] = verts.nextIndex;
                    verts.Add(Vector3.Slerp(a, b, t));
                }

                indices[^1] = VertexPairs[i + 1];
                edges[i / 2] = new Edge(indices);
            }

            return edges;
        }

        /// <summary>
        /// Creates a single spherical triangle face from three edges.
        /// </summary>
        private static void CreateFace(
            Edge sideA,
            Edge sideB,
            Edge bottom,
            int divisions,
            bool reverseWinding,
            FixedSizeList<Vector3> verts,
            FixedSizeList<int> tris)
        {
            int pointsPerEdge = sideA.vertexIndices.Length;
            int vertsPerFace  = ((divisions + 3) * (divisions + 3) - (divisions + 3)) / 2;
            var map = new FixedSizeList<int>(vertsPerFace);

            map.Add(sideA.vertexIndices[0]); // Apex of the spherical triangle.

            // Inner vertices: walk down from apex to bottom edge.
            for (int row = 1; row < pointsPerEdge - 1; row++)
            {
                // Side A vertex for this row.
                map.Add(sideA.vertexIndices[row]);

                Vector3 a = verts.items[sideA.vertexIndices[row]];
                Vector3 b = verts.items[sideB.vertexIndices[row]];
                int innerCount = row - 1;

                // Interpolate vertices between side A & B.
                for (int j = 0; j < innerCount; j++)
                {
                    float t = (j + 1f) / (innerCount + 1f);
                    map.Add(verts.nextIndex);
                    verts.Add(Vector3.Slerp(a, b, t));
                }

                // Side B vertex.
                map.Add(sideB.vertexIndices[row]);
            }

            // Bottom edge vertices.
            for (int i = 0; i < pointsPerEdge; i++)
                map.Add(bottom.vertexIndices[i]);

            // Triangulate face row by row.
            int rows = divisions + 1;
            for (int row = 0; row < rows; row++)
            {
                int top = ((row + 1) * (row + 1) - row - 1) / 2;
                int bot = ((row + 2) * (row + 2) - row - 2) / 2;
                int trisInRow = 1 + 2 * row;

                for (int col = 0; col < trisInRow; col++)
                {
                    int v0, v1, v2;

                    if ((col & 1) == 0)
                    {
                        v0 = top;
                        v1 = bot + 1;
                        v2 = bot;
                        ++top;
                        ++bot;
                    }
                    else
                    {
                        v0 = top;
                        v1 = bot;
                        v2 = top - 1;
                    }

                    tris.Add(map.items[v0]);
                    tris.Add(map.items[reverseWinding ? v2 : v1]);
                    tris.Add(map.items[reverseWinding ? v1 : v2]);
                }
            }
        }

        #endregion

        #region Helper Types

        /// <summary>
        /// Simple, allocation-free list backed by a fixed-size array.
        /// </summary>
        sealed class FixedSizeList<T>
        {
            public readonly T[] items;
            public int nextIndex;

            public FixedSizeList(int size) => items = new T[size];

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public void Add(T item) => items[nextIndex++] = item;

            public void AddRange(IEnumerable<T> source)
            {
                foreach (var s in source) Add(s);
            }
        }

        /// <summary>
        /// Edge wrapper holding precomputed vertex indices for quick access.
        /// </summary>
        sealed class Edge
        {
            public readonly int[] vertexIndices;
            public Edge(int[] indices) => vertexIndices = indices;
        }

        #endregion
    }
} 
------------------------------

 -- OffsetMap.compute --
#pragma kernel initializeOffsets
#pragma kernel calculateOffsets

// Offset buffer generation for a monotonically increasing list of cell keys.
// Example:
// In   : {2,2,2,3,6,6,9,9,9,9}
// Out  : {x,x,0,3,x,x,4,x,x,6}
//        ↳ Offsets[6] == 4  -> first index where cell '6' begins.
//
// IMPORTANT: `offsets` must be pre-filled with a value >= `numInputs`.
StructuredBuffer<uint> sortedKeys;
RWStructuredBuffer<uint> offsets;
uint numInputs;

bool shouldWriteOffset(uint key, uint prevKey)
{
    return key != prevKey;
}

[numthreads(256, 1, 1)]
void initializeOffsets(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numInputs) { return; }
	offsets[id.x] = numInputs;
}

[numthreads(256, 1, 1)]
void calculateOffsets(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numInputs) { return; }

	uint currentIndex = id.x;
	uint nullKey = numInputs;
	
	uint currentKey = sortedKeys[currentIndex];
	uint previousKey = (currentIndex == 0) ? nullKey : sortedKeys[currentIndex - 1];
	
	if (shouldWriteOffset(currentKey, previousKey))
	{
		offsets[currentKey] = currentIndex;
	}
}
------------------------------

 -- ScanStride.cs --
using Project.Helpers;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Project.GPUSorting
{
    public class ScanStride
    {
        private const int scanKernel = 0;        // localPrefixSum
        private const int combineKernel = 1;     // addGroupOffsets

        private static readonly int dataID = Shader.PropertyToID("data");
        private static readonly int workGroupTotalsID = Shader.PropertyToID("workGroupTotals");
        private static readonly int totalCountID = Shader.PropertyToID("totalCount");
        private readonly ComputeShader cs;

        private readonly Dictionary<int, ComputeBuffer> freeBuffers = new();

        public ScanStride()
        {
            cs = ComputeHelper.LoadComputeShader("ScanStrideTest");
        }

        public void Run(ComputeBuffer elements)
        {
            // Calculate number of groups/blocks to run in shader
            cs.GetKernelThreadGroupSizes(scanKernel, out uint threadsPerGroup, out _, out _);
            int numGroups = Mathf.CeilToInt(elements.count / 2f / threadsPerGroup);

            if (!freeBuffers.TryGetValue(numGroups, out ComputeBuffer groupSumBuffer))
            {
                groupSumBuffer = ComputeHelper.CreateStructuredBuffer<uint>(numGroups);
                freeBuffers.Add(numGroups, groupSumBuffer);
            }

            cs.SetBuffer(scanKernel, dataID, elements);
            cs.SetBuffer(scanKernel, workGroupTotalsID, groupSumBuffer);
            cs.SetInt(totalCountID, elements.count);

            // Run scan kernel
            cs.Dispatch(scanKernel, numGroups, 1, 1);

            // If more than one group, then the groups need to be adjusted by adding on all preceding groupSums to each group
            // This can be done efficiently by first calculating the scan of the groupSums
            if (numGroups > 1)
            {
                // Recursively calculate scan groupSums
                Run(groupSumBuffer);

                // Add groupSums
                cs.SetBuffer(combineKernel, dataID, elements);
                cs.SetBuffer(combineKernel, workGroupTotalsID, groupSumBuffer);
                cs.SetInt(totalCountID, elements.count);
                cs.Dispatch(combineKernel, numGroups, 1, 1);
            }
        }

        public void Release()
        {
            foreach (var b in freeBuffers)
            {
                ComputeHelper.Release(b.Value);
            }
        }
    }
}
------------------------------

 -- ScanStrideTest.compute --
#pragma kernel localPrefixSum
#pragma kernel addGroupOffsets

// Exclusive prefix-sum (Blelloch scan) on the GPU.
// Each thread processes two elements; one work-group handles ITEMS_PER_GROUP values.
// Reference: GPU Gems 3 – Chapter 39, adapted for modern HLSL.

static const uint GROUP_SIZE        = 256;
static const uint ITEMS_PER_GROUP   = GROUP_SIZE * 2;

RWStructuredBuffer<uint> data;            // Source & destination buffer
RWStructuredBuffer<uint> workGroupTotals; // Per-group totals used for later accumulation
uint totalCount;                          // Actual number of valid elements in the buffer

groupshared uint sharedMem[ITEMS_PER_GROUP];

void StoreToShared(uint globalIdxA, uint globalIdxB, uint localIdxA, uint localIdxB, bool hasA, bool hasB)
{
    sharedMem[localIdxA] = hasA ? data[globalIdxA] : 0;
    sharedMem[localIdxB] = hasB ? data[globalIdxB] : 0;
}

void UpSweep(uint localId, inout uint stride)
{
    for (uint activeThreads = GROUP_SIZE; activeThreads > 0; activeThreads >>= 1)
    {
        GroupMemoryBarrierWithGroupSync();

        if (localId < activeThreads)
        {
            uint idxA = stride * ((localId << 1) + 1) - 1;
            uint idxB = idxA + stride;
            sharedMem[idxB] += sharedMem[idxA];
        }
        stride <<= 1;
    }
}

void DownSweep(uint localId, inout uint stride)
{
    for (uint activeThreads = 1; activeThreads <= GROUP_SIZE; activeThreads <<= 1)
    {
        GroupMemoryBarrierWithGroupSync();
        stride >>= 1;

        if (localId < activeThreads)
        {
            uint idxA = stride * ((localId << 1) + 1) - 1;
            uint idxB = idxA + stride;
            uint tmp      = sharedMem[idxA];
            sharedMem[idxA] = sharedMem[idxB];
            sharedMem[idxB] += tmp;
        }
    }
}

[numthreads(GROUP_SIZE, 1, 1)]
void localPrefixSum(uint dispatchThread : SV_DispatchThreadID,
                    uint localThread   : SV_GroupThreadID,
                    uint groupId       : SV_GroupID)
{
    uint localIdxA  = (localThread << 1);
    uint localIdxB  = localIdxA + 1;
    uint globalIdxA = (dispatchThread << 1);
    uint globalIdxB = globalIdxA + 1;

    bool hasA = globalIdxA < totalCount;
    bool hasB = globalIdxB < totalCount;

    // Stage 0 – write input values into shared memory
    StoreToShared(globalIdxA, globalIdxB, localIdxA, localIdxB, hasA, hasB);

    // Stage 1 – reduction (up-sweep)
    uint stride = 1;
    UpSweep(localThread, stride);

    // Thread 0 now owns the total for this work-group.
    if (localThread == 0)
    {
        workGroupTotals[groupId]          = sharedMem[ITEMS_PER_GROUP - 1];
        sharedMem[ITEMS_PER_GROUP - 1] = 0; // Convert to exclusive scan
    }

    // Stage 2 – propagate prefixes (down-sweep)
    DownSweep(localThread, stride);

    GroupMemoryBarrierWithGroupSync();

    if (hasA) data[globalIdxA] = sharedMem[localIdxA];
    if (hasB) data[globalIdxB] = sharedMem[localIdxB];
}

[numthreads(GROUP_SIZE, 1, 1)]
void addGroupOffsets(uint dispatchThread : SV_DispatchThreadID,
                     uint groupId        : SV_GroupID)
{
    uint globalIdxA = (dispatchThread << 1);
    uint globalIdxB = globalIdxA + 1;

    uint offset = workGroupTotals[groupId];

    if (globalIdxA < totalCount) data[globalIdxA] += offset;
    if (globalIdxB < totalCount) data[globalIdxB] += offset;
}
------------------------------

 -- SceneMetrics.cs --
using System;
using UnityEngine;
using UnityEngine.SceneManagement;
using Unity.Profiling;
using UnityEngine.Rendering;
using System.IO;
using Project.Fluid.Simulation;
using Project.Fluid2D.Simulation;

public class SceneMetrics : MonoBehaviour
{
    // Interval in seconds between metric refreshes
    public float metricInterval = 1f;

    // Toggle on-screen overlay
    public bool showOverlay = true;

    // Toggle saving metrics to CSV file in persistent data path
    public bool saveToFile = true;
    public string fileName = "metrics_log.csv";

    private float _timer;
    private int _frameCounter;
    private string _formattedMetrics = string.Empty;
    private GUIStyle _labelStyle;

#if UNITY_2020_2_OR_NEWER
    private ProfilerRecorder _videoMemoryRecorder;
#endif

    private float _cpuFrameMs;
    private float _gpuFrameMs;

    private string _cpuName;
    private string _gpuName;

    private string _filePath;

    private void Awake()
    {
        _labelStyle = new GUIStyle
        {
            normal = { textColor = Color.white },
            fontSize = 14
        };

        _cpuName = SystemInfo.processorType;
        _gpuName = SystemInfo.graphicsDeviceName;
    }

    private void OnEnable()
    {
        if (!Application.isPlaying) return;
#if UNITY_2020_2_OR_NEWER
        _videoMemoryRecorder = ProfilerRecorder.StartNew(ProfilerCategory.Memory, "Video Memory Used");
#endif
        FrameTimingManager.CaptureFrameTimings();
        // Prepare unique file path with timestamp and scene name
        string datedFileName = $"{Path.GetFileNameWithoutExtension(fileName)}_{DateTime.UtcNow:yyyyMMdd_HHmmss}_{SceneManager.GetActiveScene().name}{Path.GetExtension(fileName)}";
        string exeDir = Path.GetDirectoryName(Application.dataPath); // Folder containing the executable
        _filePath = Path.Combine(exeDir ?? Application.dataPath, datedFileName);
        if (saveToFile && !File.Exists(_filePath))
        {
            File.WriteAllText(_filePath,
                "Timestamp,CPUName,GPUName,SceneName,FPS,ObjectCount,ParticleCount,ParticleMemMB,ShaderMemMB,MemoryMB,CPUms,GPUms,VRAMMB\n");
        }
    }

    private void OnDisable()
    {
        if (!Application.isPlaying) return;
#if UNITY_2020_2_OR_NEWER
        if (_videoMemoryRecorder.Valid) _videoMemoryRecorder.Dispose();
#endif
    }

    private void Update()
    {
        _timer += Time.unscaledDeltaTime;
        _frameCounter++;

        if (_timer >= metricInterval)
        {
            CollectMetrics();
            _timer = 0f;
            _frameCounter = 0;
        }
    }

    private void OnGUI()
    {
        if (!showOverlay) return;
        GUI.Label(new Rect(10, 10, 400, 80), _formattedMetrics, _labelStyle);
    }

    private void CollectMetrics()
    {
        float fps = _frameCounter / _timer;
        int objectCount = CountSceneObjects();
        int particleCount = CountParticles();
        long particleMemMB = CalculateParticleMemoryMB();
        long memoryMB = GC.GetTotalMemory(false) / (1024 * 1024);

        // Frame timings
        FrameTiming[] timings = new FrameTiming[1];
        if (FrameTimingManager.GetLatestTimings(1, timings) > 0)
        {
            _cpuFrameMs = (float)timings[0].cpuFrameTime;
            _gpuFrameMs = (float)timings[0].gpuFrameTime;
        }

        // VRAM usage
        long vramMB = -1;
#if UNITY_2020_2_OR_NEWER
        if (_videoMemoryRecorder.Valid && _videoMemoryRecorder.LastValue > 0)
        {
            vramMB = (long)(_videoMemoryRecorder.LastValue / (1024f * 1024f));
        }
#endif

        // Scene name
        string sceneName = SceneManager.GetActiveScene().name;

        _formattedMetrics = $"Scene: {sceneName}\nCPU: {_cpuName}\nGPU: {_gpuName}";
        long shaderMemMB = vramMB >= 0 ? Math.Max(vramMB - particleMemMB, 0) : -1;

        _formattedMetrics +=
            $"\nFPS: {fps:F1}\nObjects: {objectCount}\nParticles: {particleCount}\nParticle Mem: {particleMemMB} MB";
        if (shaderMemMB >= 0)
            _formattedMetrics += $"\nShader Mem: {shaderMemMB} MB";
        _formattedMetrics += $"\nMemory: {memoryMB} MB";
        _formattedMetrics += $"\nCPU Frame: {_cpuFrameMs:F2} ms\nGPU Frame: {_gpuFrameMs:F2} ms";
        if (vramMB >= 0)
            _formattedMetrics += $"\nVRAM: {vramMB} MB";

        if (saveToFile)
        {
            string timestamp = DateTime.UtcNow.ToString("o");
            string line =
                $"{timestamp},\"{_cpuName}\",\"{_gpuName}\",\"{sceneName}\",{fps:F2},{objectCount},{particleCount},{particleMemMB},{shaderMemMB},{memoryMB},{_cpuFrameMs:F2},{_gpuFrameMs:F2},{vramMB}";
            File.AppendAllText(_filePath, line + "\n");
        }

        Debug.Log($"[SceneMetrics] {_formattedMetrics.Replace("\n", ", ")}");
    }

    private int CountSceneObjects()
    {
        int count = 0;
        var scene = SceneManager.GetActiveScene();
        foreach (var root in scene.GetRootGameObjects())
        {
            count += root.GetComponentsInChildren<Transform>(true).Length;
        }
        return count;
    }

    private int CountParticles()
    {
        int total = 0;

        // Legacy/Unity particle systems
        foreach (var ps in FindObjectsOfType<ParticleSystem>())
        {
            total += ps.particleCount;
        }

        // 3D fluid simulations
        foreach (var sim in FindObjectsOfType<Simulation3D>())
        {
            if (sim != null && sim.positionBuffer != null)
            {
                total += sim.positionBuffer.count;
            }
        }

        // 2D fluid simulations
        foreach (var sim2D in FindObjectsOfType<Simulation2D>())
        {
            total += sim2D.numParticles;
        }

        return total;
    }

    private long CalculateParticleMemoryMB()
    {
        long totalBytes = 0;

        void AddBufferSize(ComputeBuffer buffer)
        {
            if (buffer != null)
                totalBytes += (long)buffer.count * buffer.stride;
        }

        // 3D simulations
        foreach (var sim in FindObjectsOfType<Simulation3D>())
        {
            AddBufferSize(sim.positionBuffer);
            AddBufferSize(sim.predictedPositionsBuffer);
            AddBufferSize(sim.velocityBuffer);
            AddBufferSize(sim.densityBuffer);
            AddBufferSize(sim.foamBuffer);
        }

        // 2D simulations
        foreach (var sim2D in FindObjectsOfType<Simulation2D>())
        {
            AddBufferSize(sim2D.positionBuffer);
            AddBufferSize(sim2D.velocityBuffer);
            AddBufferSize(sim2D.densityBuffer);
        }

        return totalBytes / (1024 * 1024);
    }
} 
------------------------------

 -- SpatialIndex.cs --
using Project.GPUSorting;
using UnityEngine;
using Project.Helpers.Internal;

namespace Project.Helpers
{
	public class SpatialIndex
	{
		public ComputeBuffer spatialKeys;
		public ComputeBuffer spatialIndices;
		public ComputeBuffer spatialOffsets;

		private readonly GPUCountSort _gpuSort = new();
		private readonly SpatialShiftCalc _spatialOffsetsCalc = new();

		public SpatialIndex(int size)
		{
			AllocateBuffers(size);
		}

		public void Resize(int newSize)
		{
			AllocateBuffers(newSize);
		}

		// Populates the offset table after sorting the key buffer. The accompanying index buffer can
		// be used to reorder any related data buffer in the same fashion.
		public void Run()
		{
			_gpuSort.Run(spatialIndices, spatialKeys, (uint)(spatialKeys.count - 1));
			_spatialOffsetsCalc.Run(true, spatialKeys, spatialOffsets);
		}

		public void Release()
		{
			_gpuSort.Release();
			ComputeHelper.Release(spatialKeys, spatialIndices, spatialOffsets);
		}

		private void AllocateBuffers(int bufferSize)
		{
			ComputeHelper.CreateStructuredBuffer<uint>(ref spatialKeys, bufferSize);
			ComputeHelper.CreateStructuredBuffer<uint>(ref spatialIndices, bufferSize);
			ComputeHelper.CreateStructuredBuffer<uint>(ref spatialOffsets, bufferSize);
		}
	}
}
------------------------------

 -- SpatialShiftCalc.cs --
using Project.Helpers;
using UnityEngine;

namespace Project.Helpers.Internal
{
	public class SpatialShiftCalc
	{
		private readonly ComputeShader _computeShader = ComputeHelper.LoadComputeShader("OffsetMap");
		private static readonly int NUM_INPUTS = Shader.PropertyToID("numInputs");
		private static readonly int OFFSETS = Shader.PropertyToID("offsets");
		private static readonly int SORTED_KEYS = Shader.PropertyToID("sortedKeys");

		private const int INIT_KERNEL = 0;
		private const int OFFSETS_KERNEL = 1;


		// Executes the offset calculation. If 'shouldInit' is true, the offset buffer is initialised prior to the main dispatch.
		public void Run(bool shouldInit, ComputeBuffer keysBuffer, ComputeBuffer offsetBuffer)
		{
			ValidateInputCounts(keysBuffer, offsetBuffer);
			SetNumInputs(keysBuffer);

			if (shouldInit)
			{
				InitializeOffsetBuffer(offsetBuffer);
			}

			DispatchOffsetCalculation(keysBuffer, offsetBuffer);
		}

		void ValidateInputCounts(ComputeBuffer keysBuffer, ComputeBuffer offsetBuffer)
		{
			if (keysBuffer.count != offsetBuffer.count)
			{
				throw new System.Exception("Input buffer count mismatch");
			}
		}

		void SetNumInputs(ComputeBuffer keysBuffer)
		{
			_computeShader.SetInt(NUM_INPUTS, keysBuffer.count);
		}

		void InitializeOffsetBuffer(ComputeBuffer offsetBuffer)
		{
			_computeShader.SetBuffer(INIT_KERNEL, OFFSETS, offsetBuffer);
			ComputeHelper.Dispatch(_computeShader, offsetBuffer.count, kernelIndex: INIT_KERNEL);
		}

		void DispatchOffsetCalculation(ComputeBuffer keysBuffer, ComputeBuffer offsetBuffer)
		{
			_computeShader.SetBuffer(OFFSETS_KERNEL, OFFSETS, offsetBuffer);
			_computeShader.SetBuffer(OFFSETS_KERNEL, SORTED_KEYS, keysBuffer);
			ComputeHelper.Dispatch(_computeShader, keysBuffer.count, kernelIndex: OFFSETS_KERNEL);
		}
	}
}
------------------------------

 -- MarchingCubeKernel.compute --
#pragma kernel executeCube

struct MCVert {
	float3 position;
	float3 normal;
};

struct MCTri {
	MCVert c;
	MCVert b;
	MCVert a;
};
// LUT starting index per config
static const int OFFSETS[256] = {0, 0, 3, 6, 12, 15, 21, 27, 36, 39, 45, 51, 60, 66, 75, 84, 90, 93, 99, 105, 114, 120, 129, 138, 150, 156, 165, 174, 186, 195, 207, 219, 228, 231, 237, 243, 252, 258, 267, 276, 288, 294, 303, 312, 324, 333, 345, 357, 366, 372, 381, 390, 396, 405, 417, 429, 438, 447, 459, 471, 480, 492, 507, 522, 528, 531, 537, 543, 552, 558, 567, 576, 588, 594, 603, 612, 624, 633, 645, 657, 666, 672, 681, 690, 702, 711, 723, 735, 750, 759, 771, 783, 798, 810, 825, 840, 852, 858, 867, 876, 888, 897, 909, 915, 924, 933, 945, 957, 972, 984, 999, 1008, 1014, 1023, 1035, 1047, 1056, 1068, 1083, 1092, 1098, 1110, 1125, 1140, 1152, 1167, 1173, 1185, 1188, 1191, 1197, 1203, 1212, 1218, 1227, 1236, 1248, 1254, 1263, 1272, 1284, 1293, 1305, 1317, 1326, 1332, 1341, 1350, 1362, 1371, 1383, 1395, 1410, 1419, 1425, 1437, 1446, 1458, 1467, 1482, 1488, 1494, 1503, 1512, 1524, 1533, 1545, 1557, 1572, 1581, 1593, 1605, 1620, 1632, 1647, 1662, 1674, 1683, 1695, 1707, 1716, 1728, 1743, 1758, 1770, 1782, 1791, 1806, 1812, 1827, 1839, 1845, 1848, 1854, 1863, 1872, 1884, 1893, 1905, 1917, 1932, 1941, 1953, 1965, 1980, 1986, 1995, 2004, 2010, 2019, 2031, 2043, 2058, 2070, 2085, 2100, 2106, 2118, 2127, 2142, 2154, 2163, 2169, 2181, 2184, 2193, 2205, 2217, 2232, 2244, 2259, 2268, 2280, 2292, 2307, 2322, 2328, 2337, 2349, 2355, 2358, 2364, 2373, 2382, 2388, 2397, 2409, 2415, 2418, 2427, 2433, 2445, 2448, 2454, 2457, 2460};
// Index count per config (tri * 3)
static const int LENGTHS[256] = {0, 3, 3, 6, 3, 6, 6, 9, 3, 6, 6, 9, 6, 9, 9, 6, 3, 6, 6, 9, 6, 9, 9, 12, 6, 9, 9, 12, 9, 12, 12, 9, 3, 6, 6, 9, 6, 9, 9, 12, 6, 9, 9, 12, 9, 12, 12, 9, 6, 9, 9, 6, 9, 12, 12, 9, 9, 12, 12, 9, 12, 15, 15, 6, 3, 6, 6, 9, 6, 9, 9, 12, 6, 9, 9, 12, 9, 12, 12, 9, 6, 9, 9, 12, 9, 12, 12, 15, 9, 12, 12, 15, 12, 15, 15, 12, 6, 9, 9, 12, 9, 12, 6, 9, 9, 12, 12, 15, 12, 15, 9, 6, 9, 12, 12, 9, 12, 15, 9, 6, 12, 15, 15, 12, 15, 6, 12, 3, 3, 6, 6, 9, 6, 9, 9, 12, 6, 9, 9, 12, 9, 12, 12, 9, 6, 9, 9, 12, 9, 12, 12, 15, 9, 6, 12, 9, 12, 9, 15, 6, 6, 9, 9, 12, 9, 12, 12, 15, 9, 12, 12, 15, 12, 15, 15, 12, 9, 12, 12, 9, 12, 15, 15, 12, 12, 9, 15, 6, 15, 12, 6, 3, 6, 9, 9, 12, 9, 12, 12, 15, 9, 12, 12, 15, 6, 9, 9, 6, 9, 12, 12, 15, 12, 15, 15, 6, 12, 9, 15, 12, 9, 6, 12, 3, 9, 12, 12, 15, 12, 15, 9, 12, 12, 15, 15, 6, 9, 12, 6, 3, 6, 9, 9, 6, 9, 12, 6, 3, 9, 6, 12, 3, 6, 3, 3, 0};

static const int CORNER_INDEX_A_FROM_EDGE[12] = {0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3};
static const int CORNER_INDEX_B_FROM_EDGE[12] = {1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7};

AppendStructuredBuffer<MCTri> triStream;
RWStructuredBuffer<int> lut;
Texture3D<float> DensityMap;
SamplerState linearClampSampler;

const uint3 densityMapSize;
const float isoLevel;
const float3 scale;

float3 coordToWorld(int3 coord) {
    return (coord / (densityMapSize - 1.0)) - 0.5f;
}

int indexFromCoord(int3 coord) {
    return coord.z * densityMapSize.x * densityMapSize.y + coord.y * densityMapSize.z + coord.x;
}

float densityAt(uint3 coord)
{
	bool isEdge = any(coord <= 0 || coord >= densityMapSize - 1);
	if (isEdge) return isoLevel;
	float3 uvw = coord / (float3) (densityMapSize - 1);
	return -DensityMap.SampleLevel(linearClampSampler, uvw, 0);
}

float3 computeNormal(int3 coord) {
	
	int3 offsetX = int3(1, 0, 0);
	int3 offsetY = int3(0, 1, 0);
	int3 offsetZ = int3(0, 0, 1);

	float dx = densityAt(coord + offsetX) - densityAt(coord - offsetX);
	float dy = densityAt(coord + offsetY) - densityAt(coord - offsetY);
	float dz = densityAt(coord + offsetZ) - densityAt(coord - offsetZ);

	return normalize(float3(dx, dy, dz));
}

// Build vertex along edge
MCVert buildVert(int3 coordA, int3 coordB) {
	
	float3 posA = coordToWorld(coordA);
	float3 posB = coordToWorld(coordB);
	float densityA = densityAt(coordA);
	float densityB = densityAt(coordB);

	// Interpolate corner points with density values
	float t = (isoLevel - densityA) / (densityB - densityA);
	float3 position = posA + t * (posB - posA);

	float3 normalA = computeNormal(coordA);
	float3 normalB = computeNormal(coordB);
	float3 normal = normalize(normalA + t * (normalB - normalA));

	MCVert vertex;
	vertex.position = position * scale;
	vertex.normal = normal;

	return vertex;
}

[numthreads(8,8,8)]
void executeCube (int3 id : SV_DispatchThreadID)
{   
    int3 numCubesPerAxis = densityMapSize - 1;
	if (id.x >= numCubesPerAxis.x || id.y >= numCubesPerAxis.y || id.z >= numCubesPerAxis.z) {
		return;
	}

	int3 coord = id;

	// Corner coords
	int3 cornerCoords[8];
	cornerCoords[0] = coord + int3(0, 0, 0);
	cornerCoords[1] = coord + int3(1, 0, 0);
	cornerCoords[2] = coord + int3(1, 0, 1);
	cornerCoords[3] = coord + int3(0, 0, 1);
	cornerCoords[4] = coord + int3(0, 1, 0);
	cornerCoords[5] = coord + int3(1, 1, 0);
	cornerCoords[6] = coord + int3(1, 1, 1);
	cornerCoords[7] = coord + int3(0, 1, 1);


	// Determine cube configuration (0..255)
	int cubeConfiguration = 0;
	for (int i = 0; i < 8; i ++) {
		if (densityAt(cornerCoords[i]) < isoLevel) {
			cubeConfiguration |= (1 << i);
		}
	}

	int numIndices = LENGTHS[cubeConfiguration];
	int offset = OFFSETS[cubeConfiguration];

	for (int i = 0; i < numIndices; i += 3) {
		// Edge indices
		int v0 = lut[offset + i];
		int v1 = lut[offset + 1 + i];
		int v2 = lut[offset + 2 + i];

		int a0 = CORNER_INDEX_A_FROM_EDGE[v0];
		int b0 = CORNER_INDEX_B_FROM_EDGE[v0];

		int a1 = CORNER_INDEX_A_FROM_EDGE[v1];
		int b1 = CORNER_INDEX_B_FROM_EDGE[v1];

		int a2 = CORNER_INDEX_A_FROM_EDGE[v2];
		int b2 = CORNER_INDEX_B_FROM_EDGE[v2];

		MCVert vertexA = buildVert(cornerCoords[a0], cornerCoords[b0]);
		MCVert vertexB = buildVert(cornerCoords[a1], cornerCoords[b1]);
		MCVert vertexC = buildVert(cornerCoords[a2], cornerCoords[b2]);

		// Emit triangle
		MCTri tri;
		tri.a = vertexC;
		tri.b = vertexB;
		tri.c = vertexA;
		triStream.Append(tri);
	}
}

------------------------------

 -- MarchingCubesBuilder.cs --
using System;
using UnityEngine;
using Project.Helpers;
using System.Linq;

namespace Project.Fluid.Rendering
{

    public class MarchingCubesBuilder
    {
        // Private fields
        private readonly ComputeShader _marchingCubesCS;
        private readonly ComputeBuffer _lutBuffer;
        private ComputeBuffer _triangleBuffer;

        public MarchingCubesBuilder()
        {
            // Try load compute shader from Resources first
            _marchingCubesCS = Resources.Load<ComputeShader>("MarchingCubeKernel");
#if UNITY_EDITOR
            // Fallback to AssetDatabase when running in the editor (asset can be anywhere in the project)
            if (_marchingCubesCS == null)
            {
                _marchingCubesCS = UnityEditor.AssetDatabase.LoadAssetAtPath<ComputeShader>(
                    "Assets/Scripts/Rendering/Marching Cubes/MarchingCubeKernel.compute");
            }
#endif

            if (_marchingCubesCS == null)
            {
                Debug.LogError("MarchingCubes compute shader not found. Ensure the asset is located in a Resources folder or update the path in MarchingCubes.cs.");
            }

            // Lookup table contains pre-computed triangle indices for each of the 256 cube configurations
            int[] lutVals = LoadLookupTable();
            _lutBuffer = ComputeHelper.CreateStructuredBuffer(lutVals);

        }

        /// <summary>
        /// Loads and parses the marching-cubes lookup table embedded as a text asset.
        /// </summary>
        /// <returns>Array of triangle indices.</returns>
        private static int[] LoadLookupTable()
        {
            TextAsset lutAsset = Resources.Load<TextAsset>("MarchingCubesLUT");
#if UNITY_EDITOR
            if (lutAsset == null)
            {
                lutAsset = UnityEditor.AssetDatabase.LoadAssetAtPath<TextAsset>(
                    "Assets/Scripts/Rendering/Marching Cubes/MarchingCubesLUT.txt");
            }
#endif
            if (lutAsset == null)
            {
                Debug.LogError("MarchingCubes LUT asset not found. Ensure the file is located in a Resources folder or update the path in MarchingCubes.cs.");
                return Array.Empty<int>();
            }

            string lutString = lutAsset.text;
            return lutString.Trim().Split(',').Select(int.Parse).ToArray();
        }

        private void ApplyComputeSettings(RenderTexture densityMap, Vector3 scale, float isoLevel, ComputeBuffer triangleBuffer)
        {
            _marchingCubesCS.SetBuffer(0, "triStream", triangleBuffer);
            _marchingCubesCS.SetBuffer(0, "lut", _lutBuffer);

            _marchingCubesCS.SetTexture(0, "DensityMap", densityMap);
            _marchingCubesCS.SetInts("densityMapSize", densityMap.width, densityMap.height, densityMap.volumeDepth);
            _marchingCubesCS.SetFloat("isoLevel", isoLevel);
            _marchingCubesCS.SetVector("scale", scale);
        }

        public ComputeBuffer Run(RenderTexture densityTexture, Vector3 scale, float isoLevel)
        {
            CreateTriangleBuffer(densityTexture.width);
            ApplyComputeSettings(densityTexture, scale, isoLevel, _triangleBuffer);

            int numVoxelsPerX = densityTexture.width - 1;
            int numVoxelsPerY = densityTexture.height - 1;
            int numVoxelsPerZ = densityTexture.volumeDepth - 1;
            ComputeHelper.Dispatch(_marchingCubesCS, numVoxelsPerX, numVoxelsPerY, numVoxelsPerZ, 0);

            return _triangleBuffer;
        }

        private void CreateTriangleBuffer(int resolution, bool warnIfExceedsMaxTheoreticalSize = false)
        {
            int numVoxelsPerAxis = resolution - 1;
            int numVoxels = numVoxelsPerAxis * numVoxelsPerAxis * numVoxelsPerAxis;
            int maxTriangleCount = numVoxels * 5;
            int byteSize = ComputeHelper.GetStride<Triangle>();
            const uint MAX_BYTES = 2147483648;
            uint maxEntries = MAX_BYTES / (uint)byteSize;
            if (maxEntries < maxTriangleCount && warnIfExceedsMaxTheoreticalSize)
            {
                Debug.Log("Triangle count too large for buffer.");
            }

            ComputeHelper.CreateAppendBuffer<Triangle>(ref _triangleBuffer, Math.Min((int)maxEntries, maxTriangleCount));
        }

        public void Release()
        {
            ComputeHelper.Release(_triangleBuffer, _lutBuffer);
        }


        public struct Vertex
        {
            public Vector3 position;
            public Vector3 normal;
        }

        public struct Triangle
        {
            public Vertex vertexA;
            public Vertex vertexB;
            public Vertex vertexC;
        }
    }
}
------------------------------

 -- MarchingCubesDraw.shader --
Shader "Fluid/MarchingCubesDraw"
{
    Properties
    {
        _Tint ("Tint", Color) = (1,1,1,1)
    }

    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct McVertex
            {
                float3 position;
                float3 normal;
            };

            struct VertexToFragment
            {
                float4 positionCS : SV_POSITION;
                float3 normal     : TEXCOORD0;
            };

            // The only input provided by DrawProcedural is the vertexID
            struct VertexInput
            {
                uint vertexID : SV_VertexID;
            };


            StructuredBuffer<McVertex> vertexBuffer;
            float4 _Tint;


            VertexToFragment vert (VertexInput input)
            {
                McVertex v = vertexBuffer[input.vertexID];

                VertexToFragment o;
                o.positionCS = UnityObjectToClipPos(float4(v.position, 1.0));
                o.normal     = v.normal;
                return o;
            }

            float4 frag (VertexToFragment i) : SV_Target
            {
                float3 lightDir = _WorldSpaceLightPos0;
                float lighting = saturate(dot(lightDir, normalize(i.normal))) * 0.5 + 0.5;
                return _Tint * lighting;
            }

            ENDCG
        }
    }
}

------------------------------

 -- MarchingCubesFluidRenderer.cs --
using UnityEngine;
using Project.Helpers;
using Project.Fluid.Simulation;

namespace Project.Fluid.Rendering
{
    public class MarchingCubesFluidRenderer : MonoBehaviour
    {
        // Public inspector fields
        public float isoLevel;
        public Color col;

        [Header("References")]
        public Simulation3D sim;
        public Shader drawShader;
        public ComputeShader renderArgsCompute;

        // Private fields
        private ComputeBuffer _renderArgs; 
        private MarchingCubesBuilder _marchingCubes;
        private ComputeBuffer _triangleBuffer;
        private Material _drawMat;
        private readonly Bounds _bounds = new Bounds(Vector3.zero, Vector3.one * 1000);

        void Awake()
        {
            if (sim == null)
            {
                sim = FindObjectOfType<Simulation3D>();
            }
            if (_marchingCubes == null)
            {
                _marchingCubes = new MarchingCubesBuilder();
            }
        }

        private void LateUpdate()
        {
            if (sim != null && sim.DensityMap != null)
            {
                RenderFluid(sim.DensityMap);
            }
        }


        private void RenderFluid(RenderTexture densityTexture)
        {
            _triangleBuffer = _marchingCubes.Run(densityTexture, sim.Scale, -isoLevel);

            EnsureDrawMaterial();
            EnsureRenderArgsBuffer();
            UpdateRenderArgsBuffer();

            _drawMat.SetBuffer("vertexBuffer", _triangleBuffer);
            _drawMat.SetColor("tint", col);

            // Draw the mesh using ProceduralIndirect to avoid having to read any data back to the CPU
            Graphics.DrawProceduralIndirect(_drawMat, _bounds, MeshTopology.Triangles, _renderArgs);
        }

        /// <summary>
        /// Creates the draw material if it does not already exist.
        /// </summary>
        private void EnsureDrawMaterial()
        {
            if (_drawMat == null)
            {
                _drawMat = new Material(drawShader);
            }
        }

        /// <summary>
        /// Allocates the indirect arguments buffer used by DrawProceduralIndirect.
        /// </summary>
        private void EnsureRenderArgsBuffer()
        {
            if (_renderArgs == null)
            {
                // Triangle index count, instance count, sub-mesh index, base vertex index, byte offset
                _renderArgs = new ComputeBuffer(5, sizeof(uint), ComputeBufferType.IndirectArguments);
                renderArgsCompute.SetBuffer(0, "argsBuffer", _renderArgs);
            }
        }

        /// <summary>
        /// Updates the indirect arguments buffer with the current triangle count.
        /// </summary>
        private void UpdateRenderArgsBuffer()
        {
            // Copy the current number of triangles from buffer into arguments.
            ComputeBuffer.CopyCount(_triangleBuffer, _renderArgs, 0);
            // Multiply by 3 (one vertex per index) inside the compute shader.
            renderArgsCompute.Dispatch(0, 1, 1, 1);
        }

        private void OnDestroy()
        {
            Release();
        }

        private void Release()
        {
            ComputeHelper.Release(_renderArgs);
            _marchingCubes.Release();
        }

    }
}
------------------------------

 -- RenderIndirect.compute --
// === Indirect args prep ===

#pragma kernel prepArgs

RWStructuredBuffer<uint> argsBuffer;

[numthreads(1,1,1)]
void prepArgs(uint3 id : SV_DispatchThreadID)
{
    // tri -> idx
    argsBuffer[0] *= 3;
    argsBuffer[1] = 1; // inst
    argsBuffer[2] = 0;
    argsBuffer[3] = 0;
    argsBuffer[4] = 0;
}
------------------------------

 -- FoamArgs.compute --
#pragma kernel copyCountToArgs

StructuredBuffer<uint> countBuffer;
RWStructuredBuffer<uint> argsBuffer;

[numthreads(1,1,1)]
void copyCountToArgs(uint3 id : SV_DispatchThreadID)
{
    // Copy number of active particles into render args buffer
    argsBuffer[1] = countBuffer[0];
}

------------------------------

 -- FoamPoster.shader --
Shader "Fluid/BillboardFoam"
{
    SubShader
    {
        Tags
        {
            "Queue"="Geometry"
        }
        ZWrite On
        ZTest LEqual
        Cull Off

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma target 4.5
            #include "UnityCG.cginc"

            struct FoamParticle
            {
                float3 position;
                float3 velocity;
                float lifetime;
                float scale;
            };

            StructuredBuffer<FoamParticle> Particles;
            float scale;
            float debugParam;
            int bubbleClassifyThreshold;
            int sprayClassifyThreshold;

            float remap01(float val, float minVal, float maxVal)
            {
                return saturate((val - minVal) / (maxVal - minVal));
            }

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 posWorld : TEXCOORD1;
            };

            v2f vert(appdata_base v, uint instanceID : SV_InstanceID)
            {
                v2f o;
                FoamParticle particle = Particles[instanceID];

                // Scale particle based on age
                const float remainingLifetimeDissolveStart = 3;
                float dissolveScaleT = saturate(particle.lifetime / remainingLifetimeDissolveStart);
                float speed = length(particle.velocity);
                float velScale = lerp(0.6, 1, remap01(speed, 1, 3));
                float vertScale = scale * 2 * dissolveScaleT * particle.scale * velScale;

                // Quad face camera
                float3 worldCentre = particle.position;
                float3 vertOffset = v.vertex * vertScale;
                float3 camUp = unity_CameraToWorld._m01_m11_m21;
                float3 camRight = unity_CameraToWorld._m00_m10_m20;
                float3 vertPosWorld = worldCentre + camRight * vertOffset.x + camUp * vertOffset.y;
                
                o.pos = mul(UNITY_MATRIX_VP, float4(vertPosWorld, 1));
                o.uv = v.texcoord;
                o.posWorld = worldCentre;

                return o;
            }

            float linearDepthToUnityDepth(float linearDepth)
            {
                float depth01 = (linearDepth - _ProjectionParams.y) / (_ProjectionParams.z - _ProjectionParams.y);
                return (1.0 - (depth01 * _ZBufferParams.y)) / (depth01 * _ZBufferParams.x);
            }

            float4 frag(v2f i) : SV_Target
            {
                float2 centreOffset = (i.uv - 0.5) * 2;
                float sqrDst = dot(centreOffset, centreOffset);
                if (sqrDst > 1) discard;

                float linearDepth = abs(mul(unity_MatrixV, float4(i.posWorld, 1)).z);
                return float4(1, linearDepthToUnityDepth(linearDepth), linearDepth, 1);
            }
            ENDCG
        }
    }
}
------------------------------

 -- FoamTrial.cs --
using Project.Helpers;
using UnityEngine;
using UnityEngine.Rendering;
using Project.Fluid.Simulation;

namespace Project.Fluid.Rendering
{
	public class FoamTrial : MonoBehaviour
	{
		public float scale;
		public float debugParam;
		public bool autoDraw;

		[Header("References")]
		public Shader shaderBillboard;
		public ComputeShader copyCountToArgsCompute;

		Simulation3D sim;
		Material mat;
		Mesh mesh;
		ComputeBuffer argsBuffer;
		Bounds bounds;

		void Awake()
		{
			sim = FindObjectOfType<Simulation3D>();
			if (sim == null) { enabled = false; return; }
			sim.SimulationInitCompleted += Init;
		}

		void Init(Simulation3D sim)
		{
			mat = new Material(shaderBillboard);
			mesh = MeshBuilder.GenerateQuadMesh();
            bounds = new Bounds(Vector3.zero, Vector3.one * 1000);

			ComputeHelper.CreateArgsBuffer(ref argsBuffer, mesh, sim.maxFoamParticleCount);
			copyCountToArgsCompute.SetBuffer(0, "countBuffer", sim.foamCountBuffer);
			copyCountToArgsCompute.SetBuffer(0, "argsBuffer", argsBuffer);
			mat.SetBuffer("Particles", sim.foamBuffer);
		}

		void LateUpdate()
		{
			if (sim.foamActive)
			{
				mat.SetFloat("debugParam", debugParam);
				mat.SetInt("bubbleClassifyMinNeighbours", sim.bubbleClassifyMinNeighbours);
				mat.SetInt("sprayClassifyMaxNeighbours", sim.sprayClassifyMaxNeighbours);
				mat.SetFloat("scale", scale * 0.01f);

				if (autoDraw)
				{
					copyCountToArgsCompute.Dispatch(0, 1, 1, 1);
					Graphics.DrawMeshInstancedIndirect(mesh, 0, mat, bounds, argsBuffer);
				}
			}
		}

		public void RenderWithCmdBuffer(CommandBuffer cmd)
		{
			cmd.DispatchCompute(copyCountToArgsCompute, 0, 1, 1, 1);
			cmd.DrawMeshInstancedIndirect(mesh, 0, mat, 0, argsBuffer);
		}


		private void OnDestroy()
		{
			ComputeHelper.Release(argsBuffer);
		}
	}
}
------------------------------

 -- ParticleBillboard.shader --
Shader "Fluid/ParticleBillboard" {
	Properties {
		
	}
	SubShader {

		Tags {"Queue"="Geometry" }

		Pass {

			CGPROGRAM

			#pragma vertex vert
			#pragma fragment frag
			#pragma target 4.5

			#include "UnityCG.cginc"
			
			StructuredBuffer<float3> positions;
			StructuredBuffer<float3> velocities;
			Texture2D<float4> colourMap;
			SamplerState linearClampSampler;
			float velocityMax;

			float scale;
			float3 colour;

			float4x4 localToWorld;

			struct V2F
			{
				float4 pos : SV_POSITION;
				float2 uv : TEXCOORD0;
				float3 colour : TEXCOORD1;
				float3 normal : NORMAL;
			};

			V2F vert (appdata_full v, uint instanceID : SV_InstanceID)
			{
				V2F o;
				o.uv = v.texcoord;
				o.normal = v.normal;
				
				float3 particlePosition = positions[instanceID];
				float3 localVertexScaled = v.vertex * scale * 2;
				float4 viewPos = mul(UNITY_MATRIX_V, float4(particlePosition, 1)) + float4(localVertexScaled, 0);
				o.pos = mul(UNITY_MATRIX_P, viewPos);


				float velocityMagnitude = length(velocities[instanceID]);
				float normalizedVelocity = saturate(velocityMagnitude / velocityMax);
				float gradientT = normalizedVelocity;
				o.colour = colourMap.SampleLevel(linearClampSampler, float2(gradientT, 0.5), 0);

				return o;
			}

			float4 frag (V2F i) : SV_Target
			{
				float shading = saturate(dot(_WorldSpaceLightPos0.xyz, i.normal));
				shading = (shading + 0.6) / 1.4;
				return float4(i.colour, 1);
			}

			ENDCG
		}
	}
}
------------------------------

 -- ParticleRenderer3D.cs --
using Project.Helpers;
using UnityEngine;
using Project.Fluid.Simulation;

namespace Project.Fluid.Rendering
{

	public class ParticleRenderer3D : MonoBehaviour
	{
		public enum DisplayMode
		{
			None,
			Shaded3D,
			Billboard
		}

		[Header("Settings")] public DisplayMode mode;
		public float scale;
		public Gradient colourMap;
		public int gradientResolution;
		public float velocityDisplayMax;
		public int meshResolution;

		[Header("References")] public Simulation3D sim;
		public Shader shaderShaded;
		public Shader shaderBillboard;

		Mesh _mesh;
		Material _material;
		ComputeBuffer _argsBuffer;
		Texture2D _gradientTexture;
		DisplayMode _previousMode;
		bool _requiresUpdate;

		void Awake()
		{
			if (sim == null)
			{
				sim = FindObjectOfType<Simulation3D>();
			}
			if (sim == null)
			{
				Debug.LogWarning("ParticleRenderer3D: Simulation3D not found. Disabling component.");
				enabled = false;
			}
		}

		void LateUpdate()
		{
			RefreshConfiguration();
			RenderInstances();
		}

		void RefreshConfiguration()
		{
			HandleModeChange();
			UpdateMaterialSettings();
		}

		void HandleModeChange()
		{
			if (_previousMode == mode) return;

			_previousMode = mode;
			if (mode == DisplayMode.None) return;

			if (sim == null) return;
			_mesh = mode == DisplayMode.Billboard ? MeshBuilder.GenerateQuadMesh() : MeshBuilder.GenerateSphereMesh(meshResolution);
			ComputeHelper.CreateArgsBuffer(ref _argsBuffer, _mesh, sim.positionBuffer.count);

			_material = mode switch
			{
				DisplayMode.Shaded3D => new Material(shaderShaded),
				DisplayMode.Billboard => new Material(shaderBillboard),
				_ => null
			};

			_material.SetBuffer("positions", sim.positionBuffer);
			_material.SetBuffer("velocities", sim.velocityBuffer);
			_material.SetBuffer("DebugBuffer", sim.debugBuffer);
		}

		void UpdateMaterialSettings()
		{
			if (_material == null) return;

			if (_requiresUpdate)
			{
				_requiresUpdate = false;
				TextureFromGradient(ref _gradientTexture, gradientResolution, colourMap);
				_material.SetTexture("colourMap", _gradientTexture);
			}

			_material.SetFloat("scale", scale * 0.01f);
			_material.SetFloat("velocityMax", velocityDisplayMax);

			// Temporarily reset scale to compute accurate matrix
			Vector3 cachedScale = transform.localScale;
			transform.localScale = Vector3.one;
			Matrix4x4 localToWorld = transform.localToWorldMatrix;
			transform.localScale = cachedScale;

			_material.SetMatrix("localToWorld", localToWorld);
		}

		void RenderInstances()
		{
			if (mode == DisplayMode.None || _mesh == null || _material == null) return;
			Bounds drawBounds = new Bounds(Vector3.zero, Vector3.one * 10000);
			Graphics.DrawMeshInstancedIndirect(_mesh, 0, _material, drawBounds, _argsBuffer);
		}

		public static void TextureFromGradient(ref Texture2D texture, int width, Gradient gradient, FilterMode filterMode = FilterMode.Bilinear)
		{
			if (texture == null)
			{
				texture = new Texture2D(width, 1);
			}
			else if (texture.width != width)
			{
				texture.Reinitialize(width, 1);
			}

			if (gradient == null)
			{
				gradient = new Gradient();
				gradient.SetKeys(
					new GradientColorKey[] { new(Color.black, 0), new(Color.black, 1) },
					new GradientAlphaKey[] { new(1, 0), new(1, 1) }
				);
			}

			texture.wrapMode = TextureWrapMode.Clamp;
			texture.filterMode = filterMode;

			Color[] cols = new Color[width];
			for (int i = 0; i < cols.Length; i++)
			{
				float t = i / (cols.Length - 1f);
				cols[i] = gradient.Evaluate(t);
			}

			texture.SetPixels(cols);
			texture.Apply();
		}

		private void OnValidate()
		{
			_requiresUpdate = true;
		}

		void OnDestroy()
		{
			ComputeHelper.Release(_argsBuffer);
		}
	}
}
------------------------------

 -- ParticleSurface3D.shader --
Shader "Fluid/Particle3DSurf"
{
    Properties
    {
        _MainTex("Albedo (RGB)", 2D) = "white" {}
        _Glossiness("Smoothness", Range(0,1)) = 0.5
        _Metallic("Metallic", Range(0,1)) = 0.0
    }
    SubShader
    {
        Tags
        {
            "RenderType" = "Opaque"
        }
        LOD 200

        CGPROGRAM
        #pragma surface surf Standard addshadow fullforwardshadows vertex:vert
        #pragma multi_compile_instancing
        #pragma instancing_options procedural:setup

        sampler2D _MainTex;

        struct Input
        {
            float2 uv_MainTex;
            float4 colour;
            float3 worldPos;
        };


        #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
			StructuredBuffer<float3> positions;
			StructuredBuffer<float3> velocities;
        #endif


        SamplerState linearClampSampler;
        float velocityMax;

        float scale;

        sampler2D colourMap;

        void vert(inout appdata_full v, out Input o)
        {
                UNITY_INITIALIZE_OUTPUT(Input, o);
            o.uv_MainTex = v.texcoord.xy;

            #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
				float velocityMagnitude = length(velocities[unity_InstanceID]);
				float normalizedVelocity = saturate(velocityMagnitude / velocityMax);
				float gradientT = normalizedVelocity;
				o.colour = tex2Dlod(colourMap, float4(gradientT, 0.5,0,0));
            #endif
        }

        void setup()
        {
            #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
				float3 particlePosition = positions[unity_InstanceID];

				unity_ObjectToWorld._11_21_31_41 = float4(scale, 0, 0, 0);
				unity_ObjectToWorld._12_22_32_42 = float4(0, scale, 0, 0);
				unity_ObjectToWorld._13_23_33_43 = float4(0, 0, scale, 0);
				unity_ObjectToWorld._14_24_34_44 = float4(particlePosition, 1);
				unity_WorldToObject = unity_ObjectToWorld;
				unity_WorldToObject._14_24_34 *= -1;
				unity_WorldToObject._11_22_33 = 1.0f / unity_WorldToObject._11_22_33;

            #endif
        }

        half _Glossiness;
        half _Metallic;

        void surf(Input IN, inout SurfaceOutputStandard o)
        {
            o.Albedo = IN.colour;
            o.Metallic = 0;
            o.Smoothness = 0;
            o.Alpha = 1;
        }
        ENDCG
    }
    FallBack "Diffuse"
}
------------------------------

 -- Raymarching.shader --
Shader "Fluid/Raymarching"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
                float3 viewVector : TEXCOORD1;
            };

            v2f vert(appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                float3 viewVector = mul(unity_CameraInvProjection, float4(v.uv * 2 - 1, 0, -1));
                o.viewVector = mul(unity_CameraToWorld, float4(viewVector, 0));
                return o;
            }

            Texture3D<float4> DensityMap;
            SamplerState linearClampSampler;

            const float indexOfRefraction;
            const int numRefractions;
            const float3 extinctionCoeff;

            const float3 testParams;
            const float3 boundsSize;
            const float volumeValueOffset;
            const float densityMultiplier;
            const float viewMarchStepSize;
            const float lightStepSize;
            static const float EPSILON_ADJ = 0.01;

            // Test-environment settings
            const float3 dirToSun;
            const float4 baseColor;
            const float3 colorVariation;
            const float noiseScale;
            const float secondaryNoiseScale;
            const float secondaryNoiseWeight;
            const float gradientStrength;
            const float4 cornerColorBL;
            const float4 cornerColorBR;
            const float4 cornerColorTL;
            const float4 cornerColorTR;
            const float3 tileColVariation;
            const float tileScale;
            const float tileDarkOffset;

            const float4x4 cubeLocalToWorld;
            const float4x4 cubeWorldToLocal;
            const float3 floorPos;
            const float3 floorSize;
            
            static const float3 CUBE_COL = float3(0.95, 0.3, 0.35);
            static const float IOR_AIR = 1;

            struct HitInfo
            {
                bool didHit;
                bool isInside;
                float dst;
                float3 hitPoint;
                float3 normal;
            };

            float3 convertRgbToHsv(float3 rgb)
            {
                // Handy helper – converts a colour from RGB into HSV so we can nudge its hue/sat/value.
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 p = rgb.g < rgb.b ? float4(rgb.bg, K.wz) : float4(rgb.gb, K.xy);
                float4 q = rgb.r < p.x ? float4(p.xyw, rgb.r) : float4(rgb.r, p.yzx);

                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }

            float3 convertHsvToRgb(float3 hsv)
            {
                // Converts HSV back to good old RGB for the final output.
                float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 p = abs(frac(hsv.xxx + K.xyz) * 6.0 - K.www);
                return hsv.z * lerp(K.xxx, saturate(p - K.xxx), hsv.y);
            }

            float3 adjustHsv(float3 colRGB, float hueShift, float satShift, float valShift)
            {
                float3 hsv = convertRgbToHsv(colRGB);
                return saturate(convertHsvToRgb(hsv + float3(hueShift, satShift, valShift)));
            }

            float3 adjustHsv(float3 colRGB, float3 shift)
            {
                float3 hsv = convertRgbToHsv(colRGB);
                return saturate(convertHsvToRgb(hsv + shift));
            }


            uint rngSeedUintFromUv(float2 uv)
            {
                return (uint)(uv.x * 5023 + uv.y * 96456);
            }

            // Lightweight PCG random-number generator – quick, compact and perfect for shader work.
            uint nextRandomUint(inout uint state)
            {
                state = state * 747796405 + 2891336453;
                uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
                result = (result >> 22) ^ result;
                return result;
            }

            // Returns a uniformly‐distributed random float in the range [0, 1].
            float randomUNorm(inout uint state)
            {
                return nextRandomUint(state) / 4294967295.0; // 2^32 - 1
            }

            // Simple wrapper to maintain old API naming – identical to randomUNorm.
            float randomValue(inout uint state)
            {
                return randomUNorm(state);
            }

            // Random value in a normal (Gaussian) distribution with mean = 0 and sd = 1
            float randomValueNormalDistribution(inout uint state)
            {
                const float PI = 3.1415926;
                // Box–Muller transform converts two uniform randoms into a normal distribution.
                float theta = 2 * PI * randomUNorm(state);
                float rho = sqrt(-2 * log(randomUNorm(state)));
                return rho * cos(theta);
            }

            // Returns a signed random float in the range [-1, 1].
            float randomSNorm(inout uint state)
            {
                return randomValue(state) * 2 - 1;
            }

            // Returns a float3 where each component is independently sampled in the
            // range [-1, 1]. Useful for small HSV adjustments or random vectors.
            float3 randomSNorm3(inout uint state)
            {
                return float3(randomSNorm(state), randomSNorm(state), randomSNorm(state));
            }

            // Calculate a random direction
            float3 randomDirection(inout uint state)
            {
                // Spits out a totally random 3-D direction evenly spread over the sphere.
                float x = randomValueNormalDistribution(state);
                float y = randomValueNormalDistribution(state);
                float z = randomValueNormalDistribution(state);
                return normalize(float3(x, y, z));
            }

            float2 randomPointInCircle(inout uint rngState)
            {
                const float PI = 3.1415926;
                float angle = randomUNorm(rngState) * 2 * PI;
                float2 pointOnCircle = float2(cos(angle), sin(angle));
                return pointOnCircle * sqrt(randomUNorm(rngState));
            }


            // Test intersection of ray with unit box centered at origin
            HitInfo rayUnitBox(float3 pos, float3 dir)
            {
                const float3 boxMin = -1;
                const float3 boxMax = 1;
                float3 invDir = 1 / dir;

                // Super-fast ray vs box test – no branches, just maths.
                float3 tMin = (boxMin - pos) * invDir;
                float3 tMax = (boxMax - pos) * invDir;
                float3 t1 = min(tMin, tMax);
                float3 t2 = max(tMin, tMax);
                float tNear = max(max(t1.x, t1.y), t1.z);
                float tFar = min(min(t2.x, t2.y), t2.z);

                // Set hit info
                HitInfo hitInfo = (HitInfo)0;
                hitInfo.dst = 1.#INF;
                hitInfo.didHit = tFar >= tNear && tFar > 0;
                hitInfo.isInside = tFar > tNear && tNear <= 0;

                if (hitInfo.didHit)
                {
                    float hitDst = hitInfo.isInside ? tFar : tNear;
                    float3 hitPos = pos + dir * hitDst;

                    hitInfo.dst = hitDst;
                    hitInfo.hitPoint = hitPos;

                    // Calculate normal
                    float3 o = (1 - abs(hitPos));
                    float3 absNormal = (o.x < o.y && o.x < o.z) ? float3(1, 0, 0) : (o.y < o.z) ? float3(0, 1, 0) : float3(0, 0, 1);
                    hitInfo.normal = absNormal * sign(hitPos) * (hitInfo.isInside ? -1 : 1);
                }

                return hitInfo;
            }


            uint nextRandom(inout uint state)
            {
                return nextRandomUint(state);
            }

            // Returns a float2 where:
            //   x – distance from `rayOrigin` to the first intersection with the box (0 if the origin is already inside)
            //   y – distance the ray travels while inside the box (0 if the ray misses)
            // CASE 1: Ray enters the box from outside (0 <= dstA <= dstB)
            // dstA is the distance to the closest intersection, dstB is the distance to the farthest intersection

            // CASE 2: Ray starts inside the box (dstA < 0 < dstB)
            // dstA is the distance to the intersection behind the origin, dstB is the distance to the intersection ahead

            // CASE 3: Ray does not intersect the box (dstA > dstB)

            float2 rayBoxDst(float3 boundsMin, float3 boundsMax, float3 rayOrigin, float3 rayDir)
            {
                float3 invRayDir = 1 / rayDir;
                float3 t0 = (boundsMin - rayOrigin) * invRayDir;
                float3 t1 = (boundsMax - rayOrigin) * invRayDir;
                float3 tmin = min(t0, t1);
                float3 tmax = max(t0, t1);

                float dstA = max(max(tmin.x, tmin.y), tmin.z);
                float dstB = min(tmax.x, min(tmax.y, tmax.z));
              
                float dstToBox = max(0, dstA);
                float dstInsideBox = max(0, dstB - dstToBox);
                return float2(dstToBox, dstInsideBox);
            }

            float sampleDensity(float3 pos)
            {
                float3 uvw = (pos + boundsSize * 0.5) / boundsSize;

                const float epsilon = 0.0001;
                bool isEdge = any(uvw >= 1 - epsilon || uvw <= epsilon);
                if (isEdge) return -volumeValueOffset;

                return DensityMap.SampleLevel(linearClampSampler, uvw, 0).r - volumeValueOffset;
            }


            float calculateDensityAlongRay(float3 rayPos, float3 rayDir, float stepSize)
            {
                // Test for non-normalize ray and return 0 in that case.
                // This happens when refract direction is calculated, but ray is totally reflected
                if (dot(rayDir, rayDir) < 0.9) return 0;

                float2 boundsDstInfo = rayBoxDst(-boundsSize * 0.5, boundsSize * 0.5, rayPos, rayDir);
                float dstToBounds = boundsDstInfo[0];
                float dstThroughBounds = boundsDstInfo[1];
                if (dstThroughBounds <= 0) return 0;

                float dstTravelled = 0;
                float opticalDepth = 0;
                float nudge = stepSize * 0.5;
                float3 entryPoint = rayPos + rayDir * (dstToBounds + nudge);
                dstThroughBounds -= (nudge + EPSILON_ADJ);

                while (dstTravelled < dstThroughBounds)
                {
                    rayPos = entryPoint + rayDir * dstTravelled;
                    float density = sampleDensity(rayPos) * densityMultiplier * stepSize;
                    if (density > 0)
                        opticalDepth += density;
                        
                    dstTravelled += stepSize;
                }

                return opticalDepth;
            }

            float calculateDensityAlongRay(float3 rayPos, float3 rayDir)
            {
                return calculateDensityAlongRay(rayPos, rayDir, lightStepSize);
            }

            float3 calculateClosestFaceNormal(float3 boxSize, float3 p)
            {
                float3 halfSize = boxSize * 0.5;
                float3 o = (halfSize - abs(p));
                return (o.x < o.y && o.x < o.z) ? float3(sign(p.x), 0, 0) : (o.y < o.z) ? float3(0, sign(p.y), 0) : float3(0, 0, sign(p.z));
            }

            struct LightResponse
            {
                float3 reflectDir;
                float3 refractDir;
                float reflectWeight;
                float refractWeight;
            };

            // Fresnel reflectance for unpolarised light.
            float calculateReflectance(float3 inDir, float3 normal, float iorA, float iorB)
            {
                float refractRatio = iorA / iorB;
                float cosAngleIn = -dot(inDir, normal);
                float sinSqrAngleOfRefraction = refractRatio * refractRatio * (1 - cosAngleIn * cosAngleIn);
                if (sinSqrAngleOfRefraction >= 1) return 1; // Ray is fully reflected, no refraction occurs

                float cosAngleOfRefraction = sqrt(1 - sinSqrAngleOfRefraction);
                // Perpendicular polarization
                float rPerpendicular = (iorA * cosAngleIn - iorB * cosAngleOfRefraction) / (iorA * cosAngleIn + iorB * cosAngleOfRefraction);
                rPerpendicular *= rPerpendicular;
                // Parallel polarization
                float rParallel = (iorB * cosAngleIn - iorA * cosAngleOfRefraction) / (iorB * cosAngleIn + iorA * cosAngleOfRefraction);
                rParallel *= rParallel;

                // Return the average of the perpendicular and parallel polarizations
                return (rPerpendicular + rParallel) / 2;
            }


            float3 refract(float3 inDir, float3 normal, float iorA, float iorB)
            {
                float refractRatio = iorA / iorB;
                float cosAngleIn = -dot(inDir, normal);
                float sinSqrAngleOfRefraction = refractRatio * refractRatio * (1 - cosAngleIn * cosAngleIn);
                if (sinSqrAngleOfRefraction > 1) return 0; // Ray is fully reflected, no refraction occurs

                float3 refractDir = refractRatio * inDir + (refractRatio * cosAngleIn - sqrt(1 - sinSqrAngleOfRefraction)) * normal;
                return refractDir;
            }

            float3 reflect(float3 inDir, float3 normal)
            {
                return inDir - 2 * dot(inDir, normal) * normal;
            }


            LightResponse calculateReflectionAndRefraction(float3 inDir, float3 normal, float iorA, float iorB)
            {
                LightResponse result;

                result.reflectWeight = calculateReflectance(inDir, normal, iorA, iorB);
                result.refractWeight = 1 - result.reflectWeight;

                result.reflectDir = reflect(inDir, normal);
                result.refractDir = refract(inDir, normal, iorA, iorB);

                return result;
            }

            // Estimates the gradient of the signed-distance field by sampling density
            // on the three primary axes around position `p`. The gradient direction
            // approximates the surface normal.
            float3 estimateVolumeNormal(float3 p, float sampleOffset)
            {
                float3 dx = float3(sampleOffset, 0, 0);
                float3 dy = float3(0, sampleOffset, 0);
                float3 dz = float3(0, 0, sampleOffset);

                float dX = sampleDensity(p - dx) - sampleDensity(p + dx);
                float dY = sampleDensity(p - dy) - sampleDensity(p + dy);
                float dZ = sampleDensity(p - dz) - sampleDensity(p + dz);

                return normalize(float3(dX, dY, dZ));
            }

            // Calculates a smoothed surface normal at `pos`. A gradient-based normal
            // is blended towards the nearest face normal when close to the container
            // walls to avoid noisy highlights and keep silhouettes crisp.
            float3 calculateNormal(float3 pos)
            {
                const float SAMPLE_OFFSET = 0.1;

                // Gradient normal from neighbouring density samples.
                float3 volumeNormal = estimateVolumeNormal(pos, SAMPLE_OFFSET);

                // Weight towards face normal near the bounds to smooth edges.
                float3 o = boundsSize / 2 - abs(pos);
                float faceWeight = min(o.x, min(o.y, o.z));
                float3 faceNormal = calculateClosestFaceNormal(boundsSize, pos);

                const float SMOOTH_DST = 0.3;
                const float SMOOTH_POW = 5;
                faceWeight = (1 - smoothstep(0, SMOOTH_DST, faceWeight)) * (1 - pow(saturate(volumeNormal.y), SMOOTH_POW));

                return normalize(volumeNormal * (1 - faceWeight) + faceNormal * faceWeight);
            }


            struct SurfaceInfo
            {
                float3 pos;
                float3 normal;
                float densityAlongRay;
                bool foundSurface;
            };

            bool isInsideFluid(float3 pos)
            {
                float2 boundsDstInfo = rayBoxDst(-boundsSize * 0.5, boundsSize * 0.5, pos, float3(0, 0, 1));
                return (boundsDstInfo.x <= 0 && boundsDstInfo.y > 0) && sampleDensity(pos) > 0;
            }

            SurfaceInfo findNextSurface(float3 origin, float3 rayDir, bool findNextFluidEntryPoint, uint rngState, float rngWeight, float maxDst)
            {
                SurfaceInfo info = (SurfaceInfo)0;
                if (dot(rayDir, rayDir) < 0.5) return info;

                float2 boundsDstInfo = rayBoxDst(-boundsSize * 0.5, boundsSize * 0.5, origin, rayDir);
                float r = (randomValue(rngState) - 0.5) * viewMarchStepSize * 0.4 * 1;
                bool hasExittedFluid = !isInsideFluid(origin);
                origin = origin + rayDir * (boundsDstInfo.x + r);

                float stepSize = viewMarchStepSize;
                bool hasEnteredFluid = false;
                float3 lastPosInFluid = origin;

                float dstToTest = boundsDstInfo[1] - (EPSILON_ADJ) * 2;

                for (float dst = 0; dst < dstToTest; dst += stepSize)
                {
                    bool isLastStep = dst + stepSize >= dstToTest;
                    float3 samplePos = origin + rayDir * dst;
                    float thickness = sampleDensity(samplePos) * densityMultiplier * stepSize;
                    bool insideFluid = thickness > 0;
                    if (insideFluid)
                    {
                        hasEnteredFluid = true;
                        lastPosInFluid = samplePos;
                        if (dst <= maxDst)
                        {
                            info.densityAlongRay += thickness;
                        }
                    }

                    if (!insideFluid) hasExittedFluid = true;

                    bool found;
                    if (findNextFluidEntryPoint) found = insideFluid && hasExittedFluid;
                    else found = hasEnteredFluid && (!insideFluid || isLastStep);

                    if (found)
                    {
                        info.pos = lastPosInFluid;
                        info.foundSurface = true;
                        break;
                    }
                }

                return info;
            }

            HitInfo rayBox(float3 rayPos, float3 rayDir, float3 centre, float3 size)
            {
                HitInfo hitInfo = rayUnitBox((rayPos - centre) / size, rayDir / size);
                hitInfo.hitPoint = hitInfo.hitPoint * size + centre;
                if (hitInfo.didHit) hitInfo.dst = length(hitInfo.hitPoint - rayPos);
                return hitInfo;
            }

            HitInfo rayBoxWithMatrix(float3 rayPos, float3 rayDir, float4x4 localToWorld, float4x4 worldToLocal)
            {
                float3 posLocal = mul(worldToLocal, float4(rayPos, 1));
                float3 dirLocal = mul(worldToLocal, float4(rayDir, 0));
                HitInfo hitInfo = rayUnitBox(posLocal, dirLocal);
                hitInfo.normal = normalize(mul(localToWorld, float4(hitInfo.normal, 0)));
                hitInfo.hitPoint = mul(localToWorld, float4(hitInfo.hitPoint, 1));
                if (hitInfo.didHit) hitInfo.dst = length(hitInfo.hitPoint - rayPos);
                return hitInfo;
            }

            float fastMod(float x, float y)
            {
                return (x - y * floor(x / y)); // branch-free modulus
            }

            uint hashInt2(int2 v)
            {
                return v.x * 5023 + v.y * 96456;
            }

            float2 fade(float2 t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            float rand2(float2 p) { return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453123); }
            float perlin2D(float2 p)
            {
                float2 i = floor(p);
                float2 f = frac(p);

                float a = rand2(i);
                float b = rand2(i + float2(1, 0));
                float c = rand2(i + float2(0, 1));
                float d = rand2(i + float2(1, 1));

                float2 u = fade(f);
                return lerp( lerp(a, b, u.x), lerp(c, d, u.x), u.y );
            }

            float3 calcTransmittance(float thickness)
            {
                return exp(-thickness * extinctionCoeff);
            }

            // Simple physically-inspired sky model with a hard-coded sun bloom.
            float3 sampleSky(float3 dir)
            {
                const float3 colGround = float3(0.35, 0.3, 0.35) * 0.53;
                const float3 colSkyHorizon = float3(1, 1, 1);
                const float3 colSkyZenith = float3(0.08, 0.37, 0.73);

                float sun = pow(max(0, dot(dir, dirToSun)), 500) * 1;
                float skyGradientT = pow(smoothstep(0, 0.4, dir.y), 0.35);
                float groundToSkyT = smoothstep(-0.01, 0, dir.y);
                float3 skyGradient = lerp(colSkyHorizon, colSkyZenith, skyGradientT);

                return lerp(colGround, skyGradient, groundToSkyT) + sun * (groundToSkyT >= 1);
            }

            // Returns the colour encountered by a ray `{o,d}` in the test scene.
            // Handles cube, tiled floor and default sky.
            float3 getEnv(float3 o, float3 d)
            {
                HitInfo fHit = rayBox(o, d, floorPos, floorSize);
                HitInfo cHit = rayBoxWithMatrix(o, d, cubeLocalToWorld, cubeWorldToLocal);

                if (cHit.didHit && cHit.dst < fHit.dst)
                {
                    return saturate(dot(cHit.normal, dirToSun) * 0.5 + 0.5) * CUBE_COL;
                }
                else if (fHit.didHit)
                {
                    float3 tileCol = baseColor.rgb;

                    // === Noise layers ===
                    float2 nUV = fHit.hitPoint.xz * noiseScale;
                    float n1 = perlin2D(nUV);

                    float2 nUV2 = fHit.hitPoint.xz * secondaryNoiseScale;
                    float n2 = (
                        perlin2D(nUV2) +
                        perlin2D(nUV2 + float2(1,0)) +
                        perlin2D(nUV2 + float2(-1,0)) +
                        perlin2D(nUV2 + float2(0,1)) +
                        perlin2D(nUV2 + float2(0,-1))
                    ) / 5;

                    float3 noiseVar = (n1 - 0.5) * 2 * colorVariation + (n2 - 0.5) * 2 * colorVariation * secondaryNoiseWeight;
                    float3 noisyCol = adjustHsv(float3(0.5,0.5,0.5), noiseVar);

                    float noiseMask = 1 - baseColor.a;
                    tileCol = lerp(tileCol, noisyCol, noiseMask);

                    // Corner gradient blending
                    float2 local = fHit.hitPoint.xz / floorSize.xz + 0.5;
                    local = saturate(local);
                    float3 gradBot = lerp(cornerColorBL, cornerColorBR, local.x).rgb;
                    float3 gradTop = lerp(cornerColorTL, cornerColorTR, local.x).rgb;
                    float3 gradCol = lerp(gradBot, gradTop, local.y);
                    tileCol = lerp(tileCol, gradCol, gradientStrength);

                    // Shadow map using transmittance
                    float3 sMap = calcTransmittance(calculateDensityAlongRay(fHit.hitPoint, _WorldSpaceLightPos0, lightStepSize * 2) * 2);
                    bool shadowHit = rayBoxWithMatrix(fHit.hitPoint, dirToSun, cubeLocalToWorld, cubeWorldToLocal).didHit;
                    if (shadowHit) sMap *= 0.2;
                    return tileCol * sMap;
                }

                return sampleSky(d);
            }

            // Crude anti-aliasing
            float3 getEnvAA(float3 o, float3 d)
            {
                float3 rVec = unity_CameraToWorld._m00_m10_m20;
                float3 uVec = unity_CameraToWorld._m01_m11_m21;

                float3 accum = 0;
                for (int ox = -1; ox <= 1; ox++)
                {
                    for (int oy = -1; oy <= 1; oy++)
                    {
                        float3 jFocus = (o + d) + (rVec * ox + uVec * oy) * 0.7 / _ScreenParams.x;
                        float3 jDir = normalize(jFocus - o);
                        accum += getEnv(o, jDir);
                    }
                }

                return accum / 9;
            }

            float3 gatherLight(float3 o, float3 d)
            {
                return getEnvAA(o, d);
            }

            // Primary ray-marcher that traces refraction / reflection paths through the fluid volume.
            float3 rayMarchFluid(float2 uv, float stepSize)
            {
                uint rngState = (uint)(uv.x * 1243 + uv.y * 96456);
                float3 localViewVector = mul(unity_CameraInvProjection, float4(uv * 2 - 1, 0, -1));
                float3 rayDir = normalize(mul(unity_CameraToWorld, float4(localViewVector, 0)));
                float3 rayPos = _WorldSpaceCameraPos.xyz;
                bool travellingThroughFluid = isInsideFluid(rayPos);

                float3 transmittance = 1;
                float3 light = 0;

                for (int i = 0; i < numRefractions; i++)
                {
                    float densityStepSize = lightStepSize * (i + 1); // increase step size with each iteration
                    bool searchForNextFluidEntryPoint = !travellingThroughFluid;

                    HitInfo cubeHit = rayBoxWithMatrix(rayPos, rayDir, cubeLocalToWorld, cubeWorldToLocal);
                    SurfaceInfo surfaceInfo = findNextSurface(rayPos, rayDir, searchForNextFluidEntryPoint, rngState, i == 0 ? 1 : 0, cubeHit.dst);
                    bool useCubeHit = cubeHit.didHit && cubeHit.dst < length(surfaceInfo.pos - rayPos);
                    if (!surfaceInfo.foundSurface) break;

                    transmittance *= calcTransmittance(surfaceInfo.densityAlongRay);

                    // Hit test cube
                    if (useCubeHit)
                    {
                        if (travellingThroughFluid)
                        {
                            transmittance *= calcTransmittance(calculateDensityAlongRay(cubeHit.hitPoint, cubeHit.normal, densityStepSize));
                        }
                        light += gatherLight(rayPos, rayDir) * transmittance;
                        transmittance = 0;
                        break;
                    }

                    // If light hits the floor it will be scattered in all directions (in hemisphere)
                    // Not sure how to handle this in real-time, so just break out of loop here
                    if (surfaceInfo.pos.y < -boundsSize.y / 2 + 0.05)
                    {
                        break;
                    }

                    float3 normal = calculateNormal(surfaceInfo.pos);
                    if (dot(normal, rayDir) > 0) normal = -normal;

                    // Indicies of refraction
                    float iorA = travellingThroughFluid ? indexOfRefraction : IOR_AIR;
                    float iorB = travellingThroughFluid ? IOR_AIR : indexOfRefraction;

                    // Calculate reflection and refraction, and choose which path to follow
                    LightResponse lightResponse = calculateReflectionAndRefraction(rayDir, normal, iorA, iorB);
                    float densityAlongRefractRay = calculateDensityAlongRay(surfaceInfo.pos, lightResponse.refractDir, densityStepSize);
                    float densityAlongReflectRay = calculateDensityAlongRay(surfaceInfo.pos, lightResponse.reflectDir, densityStepSize);
                    bool traceRefractedRay = densityAlongRefractRay * lightResponse.refractWeight > densityAlongReflectRay * lightResponse.reflectWeight;
                    travellingThroughFluid = traceRefractedRay != travellingThroughFluid;

                    // Approximate less interesting path
                    if (traceRefractedRay) light += gatherLight(surfaceInfo.pos, lightResponse.reflectDir) * transmittance * calcTransmittance(densityAlongReflectRay) * lightResponse.reflectWeight;
                    else light += gatherLight(surfaceInfo.pos, lightResponse.refractDir) * transmittance * calcTransmittance(densityAlongRefractRay) * lightResponse.refractWeight;

                    // Set up ray for more interesting path
                    rayPos = surfaceInfo.pos;
                    rayDir = traceRefractedRay ? lightResponse.refractDir : lightResponse.reflectDir;
                    transmittance *= (traceRefractedRay ? lightResponse.refractWeight : lightResponse.reflectWeight);
                }

                // Approximate remaining path
                float densityRemainder = calculateDensityAlongRay(rayPos, rayDir, lightStepSize);
                light += gatherLight(rayPos, rayDir) * transmittance * calcTransmittance(densityRemainder);

                return light;
            }


            float4 frag(v2f i) : SV_Target
            {
                return float4(rayMarchFluid(i.uv, viewMarchStepSize), 1);
            }
            
            ENDCG
        }
    }
}
------------------------------

 -- RaymarchRenderer.cs --
using UnityEngine;
using Project.Fluid.Simulation;

namespace Project.Fluid.Rendering
{
	[ImageEffectAllowedInSceneView]
	public class RaymarchRenderer : MonoBehaviour
	{
		[Header("Settings")]
		public float densityOffset = 150;
		public int numRefractions = 4;
		public Vector3 extinctionCoefficients;
		public float densityMultiplier = 0.001f;
		[Min(0.01f)] public float stepSize = 0.02f;
		public float lightStepSize = 0.4f;
		[Min(1)] public float indexOfRefraction = 1.33f;
		public Vector3 testParams;
		public EnvironmentSettings environmentSettings;

		[Header("References")]
		public Simulation3D sim;
		public Transform cubeTransform;
		public Shader shader;

		Material _rayMat;

		void Start()
		{
			if (shader == null)
			{
				Debug.LogError("RaymarchRenderer: Shader not assigned.");
				enabled = false;
				return;
			}
			_rayMat = new Material(shader);
			if (sim == null)
			{
				sim = FindObjectOfType<Simulation3D>();
			}
			if (sim == null)
			{
				Debug.LogWarning("RaymarchRenderer: Simulation3D not found yet.");
			}
			Camera.main.depthTextureMode = DepthTextureMode.Depth;
		}

		[ImageEffectOpaque]
		void OnRenderImage(RenderTexture inTex, RenderTexture outTex)
		{
			if (sim != null && sim.DensityMap != null && _rayMat != null && cubeTransform != null)
			{
				ApplyShaderSettings();
				Graphics.Blit(inTex, outTex, _rayMat);
			}
			else
			{
				Graphics.Blit(inTex, outTex);
			}
		}

		void ApplyShaderSettings()
		{
			SetEnvironmentUniforms();
			SetSimulationUniforms();
			SetSceneUniforms();
		}

		void SetEnvironmentUniforms()
		{
			ApplyEnvironmentUniforms(_rayMat, environmentSettings);
		}

		void SetSimulationUniforms()
		{
			if (sim == null) return;
			_rayMat.SetTexture("DensityMap", sim.DensityMap);
			_rayMat.SetVector("boundsSize", sim.Scale);
			_rayMat.SetFloat("volumeValueOffset", densityOffset);
			_rayMat.SetVector("testParams", testParams);
			_rayMat.SetFloat("indexOfRefraction", indexOfRefraction);
			_rayMat.SetFloat("densityMultiplier", densityMultiplier / 1000);
			_rayMat.SetFloat("viewMarchStepSize", stepSize);
			_rayMat.SetFloat("lightStepSize", lightStepSize);
			_rayMat.SetInt("numRefractions", numRefractions);
			_rayMat.SetVector("extinctionCoeff", extinctionCoefficients);
		}

		void SetSceneUniforms()
		{
			_rayMat.SetMatrix("cubeLocalToWorld", Matrix4x4.TRS(cubeTransform.position, cubeTransform.rotation, cubeTransform.localScale / 2));
			_rayMat.SetMatrix("cubeWorldToLocal", Matrix4x4.TRS(cubeTransform.position, cubeTransform.rotation, cubeTransform.localScale / 2).inverse);

			Vector3 flSize = new Vector3(30, 0.05f, 30);
			float flHeight = -sim.Scale.y / 2 + sim.transform.position.y - flSize.y / 2;
			_rayMat.SetVector("floorPos", new Vector3(0, flHeight, 0));
			_rayMat.SetVector("floorSize", flSize);
		}

		public static void ApplyEnvironmentUniforms(Material mat, EnvironmentSettings env)
		{
			if (env.noiseScale <= 0) env.noiseScale = 3;
			if (env.secondaryNoiseScale <= 0) env.secondaryNoiseScale = env.noiseScale * 0.5f;
			if (env.secondaryNoiseWeight == 0) env.secondaryNoiseWeight = 0.5f;
			if (env.gradientStrength == 0) env.gradientStrength = 1;
			if (env.colorVariation == Vector3.zero) env.colorVariation = new Vector3(0.2f, 0.2f, 0.2f);

			mat.SetColor("baseColor", env.baseColor);
			mat.SetVector("colorVariation", env.colorVariation);
			mat.SetFloat("noiseScale", env.noiseScale);
			mat.SetFloat("secondaryNoiseScale", env.secondaryNoiseScale);
			mat.SetFloat("secondaryNoiseWeight", env.secondaryNoiseWeight);
			mat.SetColor("cornerColorBL", env.cornerColorBL);
			mat.SetColor("cornerColorBR", env.cornerColorBR);
			mat.SetColor("cornerColorTL", env.cornerColorTL);
			mat.SetColor("cornerColorTR", env.cornerColorTR);
			mat.SetFloat("gradientStrength", env.gradientStrength);
			mat.SetVector("dirToSun", -env.light.transform.forward);
		}

		[System.Serializable]
		public struct EnvironmentSettings
		{
			public Color baseColor;
			public Vector3 colorVariation;
			public float noiseScale;
			public float secondaryNoiseScale;
			public float secondaryNoiseWeight;
			public Color cornerColorBL;
			public Color cornerColorBR;
			public Color cornerColorTL;
			public Color cornerColorTR;
			public float gradientStrength;
			public Light light;
		}
	}
}
------------------------------

 -- DepthNormalMap.shader --
Shader "Fluid/NormalsFromDepth"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            // Vertex data coming from the mesh
            struct AppData
            {
                float4 vertex : POSITION;
                float2 uv     : TEXCOORD0;
            };

            // Data that will be sent from the vertex shader to the fragment shader
            struct V2F
            {
                float2 uv  : TEXCOORD0;
                float4 pos : SV_POSITION;
            };

            // Vertex shader : transforms vertex position and passes the UV unchanged
            V2F vert(AppData v)
            {
                V2F o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv  = v.uv;
                return o;
            }

            sampler2D _MainTex;                   // Packed depth texture
            float4    _MainTex_TexelSize;         // (1/width, 1/height, width, height)
            float4x4  _CameraInvViewMatrix;       // Inverse view matrix (unused but kept for compatibility)
            int       useSmoothedDepth;           // 0 = raw depth (alpha), 1 = smoothed depth (red)

            float4 viewPos(float2 uv)
            {
                // Sample depth; choose between smoothed (R) or raw (A) channel
                float4 depthInfo = tex2D(_MainTex, uv);
                float  depth     = useSmoothedDepth ? depthInfo.r : depthInfo.a;

                // Camera origin in view space
                float3 origin = 0;

                // Convert UV (0-1) to clip space (-1..1) and unproject
                float3 viewVector = mul(unity_CameraInvProjection,
                                        float4(uv * 2 - 1, 0, -1));
                float3 dir = normalize(viewVector);

                // Return XYZ position and store depth in W
                return float4(origin + dir * depth, depth);
            }

            // Fragment shader : outputs world-space normal encoded in RGB, alpha = 1
            float4 frag(V2F i) : SV_Target
            {
                float4 posCentre = viewPos(i.uv);

                // Discard far-plane samples (sentinel value written by depth pass)
                if (posCentre.a > 10000)
                {
                    return 0;
                }

                float2 texel = _MainTex_TexelSize.xy;

                // Finite differences in X 
                float3 deltaX     = viewPos(i.uv + float2(texel.x, 0)) - posCentre;
                float3 deltaXAlt  = posCentre - viewPos(i.uv - float2(texel.x, 0));
                if (abs(deltaXAlt.z) < abs(deltaX.z))
                {
                    deltaX = deltaXAlt;
                }

                // Finite differences in Y 
                float3 deltaY     = viewPos(i.uv + float2(0, texel.y)) - posCentre;
                float3 deltaYAlt  = posCentre - viewPos(i.uv - float2(0, texel.y));
                if (abs(deltaYAlt.z) < abs(deltaY.z))
                {
                    deltaY = deltaYAlt;
                }

                // View-space normal via cross product
                float3 viewNormal  = normalize(cross(deltaY, deltaX));

                // Convert to world space
                float3 worldNormal = mul(unity_CameraToWorld, float4(viewNormal, 0));

                return float4(worldNormal, 1);
            }
            ENDCG
        }
    }
}

------------------------------

 -- DepthReduce.shader --
Shader "Fluid/DepthDownsampleCopy"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off
        ZWrite On
        ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct AppData
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct V2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            V2f vert(AppData v)
            {
                V2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                return o;
            }

            sampler2D _MainTex;

            float4 frag(V2f i, out float Depth : SV_Depth) : SV_Target
            {
                Depth = tex2D(_MainTex, i.uv).g;
                return 0;
            }
            ENDCG
        }
    }
}
------------------------------

 -- FluidSurface.shader --
Shader "Fluid/FluidRender"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "UnityCG.cginc"

            struct AppData
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct V2f
            {
                float2 uv : TEXCOORD0;
                float4 vertex : SV_POSITION;
            };

            V2f vert(AppData input)
            {
                V2f outputData;
                outputData.vertex = UnityObjectToClipPos(input.vertex);
                outputData.uv = input.uv;
                return outputData;
            }

            sampler2D _MainTex;
            sampler2D Normals;
            sampler2D Comp;
            sampler2D ShadowMap;
            
            const float3 extinctionCoefficients;
            const float3 dirToSun;
            const float3 boundsSize;
            const float refractionMultiplier;

            const float4 baseColor;
            const float3 colorVariation;
            const float noiseScale;
            const float secondaryNoiseScale;
            const float secondaryNoiseWeight;
            const float gradientStrength;
            const float4 cornerColorBL;
            const float4 cornerColorBR;
            const float4 cornerColorTL;
            const float4 cornerColorTR;
            const float sunIntensity;
            const float sunInvSize;
            const float4x4 shadowVP;
            const float3 floorPos;
            const float3 floorSize;


            /// === Debug values ===
            float3 testParams;
            int debugDisplayMode;
            float depthDisplayScale;
            float thicknessDisplayScale;
            StructuredBuffer<uint> foamCountBuffer;
            uint foamMax;

            
            struct HitInfo
            {
                bool didHit;
                bool isInside;
                float dst;
                float3 hitPoint;
                float3 normal;
            };

            
            struct LightResponse
            {
                float3 reflectDir;
                float3 refractDir;
                float reflectWeight;
                float refractWeight;
            };


            float3 worldViewDir(float2 uvCoords)
            {
                float3 viewVectorCameraSpace = mul(unity_CameraInvProjection, float4(uvCoords.xy * 2 - 1, 0, -1));
                return normalize(mul(unity_CameraToWorld, viewVectorCameraSpace));
            }

            /// Test intersection of ray with unit box centered at origin
            HitInfo rayUnitBox(float3 position, float3 direction)
            {
                const float3 boxMin = -1;
                const float3 boxMax = 1;
                float3 inverseDirection = 1 / direction;

                float3 tMin = (boxMin - position) * inverseDirection;
                float3 tMax = (boxMax - position) * inverseDirection;
                float3 t1 = min(tMin, tMax);
                float3 t2 = max(tMin, tMax);
                float tNear = max(max(t1.x, t1.y), t1.z);
                float tFar = min(min(t2.x, t2.y), t2.z);

                // Set hit info
                HitInfo hitInfo = (HitInfo)0;
                hitInfo.dst = 1.#INF;
                hitInfo.didHit = tFar >= tNear && tFar > 0;
                hitInfo.isInside = tFar > tNear && tNear <= 0;

                if (hitInfo.didHit)
                {
                    float hitDst = hitInfo.isInside ? tFar : tNear;
                    float3 hitPosition = position + direction * hitDst;

                    hitInfo.dst = hitDst;
                    hitInfo.hitPoint = hitPosition;

                    // Calculate normal
                    float3 relativeDistance = (1 - abs(hitPosition));
                    float3 absNormal = (relativeDistance.x < relativeDistance.y && relativeDistance.x < relativeDistance.z) ? float3(1, 0, 0) : (relativeDistance.y < relativeDistance.z) ? float3(0, 1, 0) : float3(0, 0, 1);
                    hitInfo.normal = absNormal * sign(hitPosition) * (hitInfo.isInside ? -1 : 1);
                }

                return hitInfo;
            }

            HitInfo rayBox(float3 rayPosition, float3 rayDirection, float3 centre, float3 size)
            {
                HitInfo hitInfo = rayUnitBox((rayPosition - centre) / size, rayDirection / size);
                hitInfo.hitPoint = hitInfo.hitPoint * size + centre;
                if (hitInfo.didHit) hitInfo.dst = length(hitInfo.hitPoint - rayPosition);
                return hitInfo;
            }

            float3 calculateClosestFaceNormal(float3 boxSize, float3 pos)
            {
                float3 halfSize = boxSize * 0.5;
                float3 offset = (halfSize - abs(pos));
                return (offset.x < offset.y && offset.x < offset.z) ? float3(sign(pos.x), 0, 0) : (offset.y < offset.z) ? float3(0, sign(pos.y), 0) : float3(0, 0, sign(pos.z));
            }

            float4 smoothEdgeNormals(float3 normal, float3 position, float3 boxSize)
            {
                // Smoothly flatten normals out at boundary edges
                float3 offset = boxSize / 2 - abs(position);
                float faceWeight = max(0, min(offset.x, offset.z));
                float3 faceNormal = calculateClosestFaceNormal(boxSize, position);
                const float smoothDst = 0.01;
                const float smoothPow = 5;
                //faceWeight = (1 - smoothstep(0, smoothDst, faceWeight)) * (1 - pow(saturate(normal.y), smoothPow));
                float cornerWeight = 1 - saturate(abs(offset.x - offset.z) * 6);
                faceWeight = 1 - smoothstep(0, smoothDst, faceWeight);
                faceWeight *= (1 - cornerWeight);

                return float4(normalize(normal * (1 - faceWeight) + faceNormal * (faceWeight)), faceWeight);
            }


            float modulo(float x, float y)
            {
                return (x - y * floor(x / y));
            }
            

            // Converts an RGB color to HSV color space
            float3 rgbToHsv(float3 colorRgb)
            {
                float4 hsvK = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 pVal = colorRgb.g < colorRgb.b ? float4(colorRgb.bg, hsvK.wz) : float4(colorRgb.gb, hsvK.xy);
                float4 qVal = colorRgb.r < pVal.x ? float4(pVal.xyw, colorRgb.r) : float4(colorRgb.r, pVal.yzx);

                float delta = qVal.x - min(qVal.w, qVal.y);
                float epsilon = 1.0e-10;
                return float3(abs(qVal.z + (qVal.w - qVal.y) / (6.0 * delta + epsilon)), delta / (qVal.x + epsilon), qVal.x);
            }

            // Converts HSV color to RGB color space using optimized formula
            float3 hsvToRgb(float3 hsvInput)
            {
                float4 hsvConstants = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 hsvTemp = abs(frac(hsvInput.xxx + hsvConstants.xyz) * 6.0 - hsvConstants.www);
                return hsvInput.z * lerp(hsvConstants.xxx, saturate(hsvTemp - hsvConstants.xxx), hsvInput.y);
            }

            float3 tweakHsv(float3 colRGB, float hueShift, float satShift, float valShift)
            {
                float3 hsv = rgbToHsv(colRGB);
                return saturate(hsvToRgb(hsv + float3(hueShift, satShift, valShift)));
            }

            float3 tweakHsv(float3 colRGB, float3 shift)
            {
                float3 hsv = rgbToHsv(colRGB);
                return saturate(hsvToRgb(hsv + shift));
            }

            uint nextRandomUint(inout uint state)
            {
                state = state * 747796405 + 2891336453;
                uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
                result = (result >> 22) ^ result;
                return result;
            }

            uint rngSeedUintFromUV(float2 uv)
            {
                return (uint)(uv.x * 5023 + uv.y * 96456);
            }

            uint nextRandom(inout uint state)
            {
                state = state * 747796405 + 2891336453;
                uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
                result = (result >> 22) ^ result;
                return result;
            }

            float randomUNorm(inout uint state)
            {
                return nextRandom(state) / 4294967295.0; // 2^32 - 1
            }

            float randomSNorm(inout uint state)
            {
                return randomUNorm(state) * 2 - 1;
            }

            float3 randomSNorm3(inout uint state)
            {
                return float3(randomSNorm(state), randomSNorm(state), randomSNorm(state));
            }


            uint hashInt2(int2 v)
            {
                return v.x * 5023 + v.y * 96456;
            }

            // ===== 2D Perlin Noise Functions =====
            float2 fade(float2 t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            float rand2(float2 p) { return frac(sin(dot(p, float2(127.1, 311.7))) * 43758.5453123); }
            float perlin2D(float2 p)
            {
                float2 i = floor(p);
                float2 f = frac(p);

                float a = rand2(i);
                float b = rand2(i + float2(1, 0));
                float c = rand2(i + float2(0, 1));
                float d = rand2(i + float2(1, 1));

                float2 u = fade(f);
                return lerp( lerp(a, b, u.x), lerp(c, d, u.x), u.y );
            }

            float3 sampleSky(float3 dir)
            {
                const float3 colGround = float3(0.35, 0.3, 0.35) * 0.53;
                const float3 colSkyHorizon = float3(1, 1, 1);
                const float3 colSkyZenith = float3(0.08, 0.37, 0.73);


                float sun = pow(max(0, dot(dir, dirToSun)), sunInvSize) * sunIntensity;
                float skyGradientT = pow(smoothstep(0, 0.4, dir.y), 0.35);
                float groundToSkyT = smoothstep(-0.01, 0, dir.y);
                float3 skyGradient = lerp(colSkyHorizon, colSkyZenith, skyGradientT);

                return lerp(colGround, skyGradient, groundToSkyT) + sun * (groundToSkyT >= 1);
            }

            float3 sampleEnvironment(float3 pos, float3 dir)
            {
                HitInfo floorInfo = rayBox(pos, dir, floorPos, floorSize);

                if (floorInfo.didHit)
                {
                    float3 tileCol = baseColor.rgb;
                    // Plane is uniform so no quadrant check needed

                    float2 noiseUV = floorInfo.hitPoint.xz * noiseScale;
                    float noiseVal1 = perlin2D(noiseUV);

                    // Second (blurred) noise layer
                    float2 noiseUV2 = floorInfo.hitPoint.xz * secondaryNoiseScale;
                    // Simple blur: average neighbour samples for softer appearance
                    float noiseVal2 = (
                        perlin2D(noiseUV2) +
                        perlin2D(noiseUV2 + float2(1,0)) +
                        perlin2D(noiseUV2 + float2(-1,0)) +
                        perlin2D(noiseUV2 + float2(0,1)) +
                        perlin2D(noiseUV2 + float2(0,-1))
                    ) / 5;

                    // Combine noise layers into hsv variation
                    float3 noiseVariation = (noiseVal1 - 0.5) * 2 * colorVariation +
                                           (noiseVal2 - 0.5) * 2 * colorVariation * secondaryNoiseWeight;

                    // Generate noisy colour by shifting a mid‐gray base so noise is visible regardless of baseColor
                    float3 noisyCol = tweakHsv(float3(0.5, 0.5, 0.5), noiseVariation);

                    // Blend between solid colour and noisy colour based on baseColor alpha (0 = fully noisy)
                    float noiseMask = 1 - baseColor.a;
                    tileCol = lerp(tileCol, noisyCol, noiseMask);

                    // ===== Corner gradient colour =====
                    float2 local = floorInfo.hitPoint.xz / floorSize.xz + 0.5; // uv 0-1 across plane
                    local = saturate(local);
                    float4 gradBottom = lerp(cornerColorBL, cornerColorBR, local.x);
                    float4 gradTop    = lerp(cornerColorTL, cornerColorTR, local.x);
                    float3 gradCol    = lerp(gradBottom, gradTop, local.y).rgb;

                    tileCol = lerp(tileCol, gradCol, gradientStrength);

                    float4 shadowClip = mul(shadowVP, float4(floorInfo.hitPoint, 1));
                    shadowClip /= shadowClip.w;
                    float2 shadowUV = shadowClip.xy * 0.5 + 0.5;
                    float shadowEdgeWeight = shadowUV.x >= 0 && shadowUV.x <= 1 && shadowUV.y >= 0 && shadowUV.y <= 1;
                    float3 shadow = tex2D(ShadowMap, shadowUV).r * shadowEdgeWeight;
                    shadow = exp(-shadow * 1 * extinctionCoefficients);

                    float ambientLight = 0.17;
                    shadow = shadow * (1 - ambientLight) + ambientLight;

                    return tileCol * shadow;
                }

                return sampleSky(dir);
            }

            /// Crude anti-aliasing
            float3 sampleEnvironmentAa(float3 pos, float3 dir)
            {
                float3 right = unity_CameraToWorld._m00_m10_m20;
                float3 up = unity_CameraToWorld._m01_m11_m21;
                float aa = 0.01;

                float3 sum = 0;
                for (int ox = -1; ox <= 1; ox++)
                {
                    for (int oy = -1; oy <= 1; oy++)
                    {
                        float3 jitteredFocusPoint = (pos + dir) + (right * ox + up * oy) * 0.7 / _ScreenParams.x;
                        float3 jDir = normalize(jitteredFocusPoint - pos);
                        sum += sampleEnvironment(pos, jDir);
                    }
                }

                return sum / 9;
            }


            // Calculate the number of pixels covered by a world-space radius at given dst from camera
            float calculateScreenSpaceRadius(float worldRadius, float depth, int imageWidth)
            {
                float widthScale = UNITY_MATRIX_P._m00; // smaller values correspond to higher fov (objects appear smaller)
                float pxPerMeter = (imageWidth * widthScale) / (2 * depth);
                return abs(pxPerMeter) * worldRadius;
            }

            // Calculate the proportion of light that is reflected at the boundary between two media (via the fresnel equations)
            float calculateReflectance(float3 inDir, float3 normal, float iorA, float iorB)
            {
                float refractRatio = iorA / iorB;
                float cosAngleIn = -dot(inDir, normal);
                float sinSqrAngleOfRefraction = refractRatio * refractRatio * (1 - cosAngleIn * cosAngleIn);
                if (sinSqrAngleOfRefraction >= 1) return 1; // Ray is fully reflected, no refraction occurs

                float cosAngleOfRefraction = sqrt(1 - sinSqrAngleOfRefraction);
                // Perpendicular polarization
                float rPerpendicular = (iorA * cosAngleIn - iorB * cosAngleOfRefraction) / (iorA * cosAngleIn + iorB * cosAngleOfRefraction);
                rPerpendicular *= rPerpendicular;
                // Parallel polarization
                float rParallel = (iorB * cosAngleIn - iorA * cosAngleOfRefraction) / (iorB * cosAngleIn + iorA * cosAngleOfRefraction);
                rParallel *= rParallel;

                // Return the average of the perpendicular and parallel polarizations
                return (rPerpendicular + rParallel) / 2;
            }


            float3 refractCustom(float3 inDir, float3 normal, float iorA, float iorB)
            {
                float refractRatio = iorA / iorB;
                float cosAngleIn = -dot(inDir, normal);
                float sinSqrAngleOfRefraction = refractRatio * refractRatio * (1 - cosAngleIn * cosAngleIn);
                if (sinSqrAngleOfRefraction > 1) return 0; // Ray is fully reflected, no refraction occurs

                float3 refractDir = refractRatio * inDir + (refractRatio * cosAngleIn - sqrt(1 - sinSqrAngleOfRefraction)) * normal;
                return refractDir;
            }

            float3 reflectCustom(float3 inDir, float3 normal)
            {
                return inDir - 2 * dot(inDir, normal) * normal;
            }


            LightResponse calculateReflectionAndRefraction(float3 inDir, float3 normal, float iorA, float iorB)
            {
                LightResponse result;

                result.reflectWeight = calculateReflectance(inDir, normal, iorA, iorB);
                result.refractWeight = 1 - result.reflectWeight;

                result.reflectDir = reflectCustom(inDir, normal);
                result.refractDir = refractCustom(inDir, normal, iorA, iorB);

                return result;
            }
            
            float4 debugModeDisplay(float depthSmooth, float depth, float thicknessSmooth, float thickness, float3 normal)
            {
                float3 col = 0;

                switch (debugDisplayMode)
                {
                case 1:
                    col = depth / depthDisplayScale;
                    break;
                case 2:
                    col = depthSmooth / depthDisplayScale;
                    break;
                case 3:
                    if (dot(normal, normal) == 0) col = 0;
                    float3 normalDisplay = normal * 0.5 + 0.5;
                    col = pow(normalDisplay, 2.2), 1;
                    break;
                case 4:
                    col = thickness / thicknessDisplayScale;
                    break;
                case 5:
                    col = thicknessSmooth / thicknessDisplayScale;
                    break;
                default:
                    col = float3(1, 0, 1);
                    break;
                }

                return float4(col, 1);
            }

            float4 frag(V2f i) : SV_Target
            {
                if (i.uv.y < 0.005)
                {
                    return i.uv.x < (foamCountBuffer[0] / (float)foamMax);
                }

                // Read data from texture
                float3 normal = tex2D(Normals, i.uv).xyz;

                float4 packedData = tex2D(Comp, i.uv);
                float depthSmooth = packedData.r;
                float thickness = packedData.g;
                float thickness_hard = packedData.b;
                float depth_hard = packedData.a;

                float4 bg = tex2D(_MainTex, float2(i.uv.x, i.uv.y));
                float foam = bg.r;
                float foamDepth = bg.b;

                //  Get test-environment colour (and early exit if view ray misses fluid)
                float3 viewDirWorld = worldViewDir(i.uv);
                float3 world = sampleEnvironmentAa(_WorldSpaceCameraPos, viewDirWorld);
                if (depthSmooth > 1000) return float4(world, 1) * (1 - foam) + foam;

                // Calculate fluid hit point and smooth out normals along edges of bounding box
                float3 hitPos = _WorldSpaceCameraPos.xyz + viewDirWorld * depthSmooth;
                float3 smoothEdgeNormal = smoothEdgeNormals(normal, hitPos, boundsSize).xyz;
                normal = normalize(normal + smoothEdgeNormal * 6 * max(0, dot(normal, smoothEdgeNormal.xyz)));

                // Debug display mode
                if (debugDisplayMode != 0)
                {
                    return debugModeDisplay(depthSmooth, depth_hard, thickness, thickness_hard, normal);
                }

                // Calculate shading 
                const float ambientLight = 0.3;
                float shading = dot(normal, dirToSun) * 0.5 + 0.5;
                shading = shading * (1 - ambientLight) + ambientLight;

                // Calculate reflection and refraction
                LightResponse lightResponse = calculateReflectionAndRefraction(viewDirWorld, normal, 1, 1.33);
                float3 reflectDir = reflectCustom(viewDirWorld, normal);

                float3 exitPos = hitPos + lightResponse.refractDir * thickness * refractionMultiplier;
                // Clamp to ensure doesn't go below floor
                exitPos += lightResponse.refractDir * max(0, floorPos.y + floorSize.y - exitPos.y) / lightResponse.refractDir.y;
           
                // Colour
                float3 transmission = exp(-thickness * extinctionCoefficients);
                float3 reflectCol = sampleEnvironmentAa(hitPos, lightResponse.reflectDir);
                float3 refractCol = sampleEnvironmentAa(exitPos, viewDirWorld);
                refractCol = refractCol * (1 - foam) + foam;
                refractCol *= transmission;

                // If foam is in front of the fluid, overwrite the reflected col with the foam col
                if (foamDepth < depthSmooth)
                {
                    reflectCol = reflectCol * (1 - foam) + foam;
                }

                // Blend between reflected and refracted col
                float3 col = lerp(reflectCol, refractCol, lightResponse.refractWeight);
                return float4(col, 1);
            }
            ENDCG
        }
    }
}
------------------------------

 -- ParticleMask.shader --
Shader "Fluid/ParticleDepth" {
    SubShader {

        Tags {"Queue"="Geometry"}
        Cull Off
        
        Pass {

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag
            #pragma target 4.5

            #include "UnityCG.cginc"
            
            // Buffers & uniforms
            StructuredBuffer<float3> Positions;   // World‐space particle centres
            float scale;                          // Radius scale of each particle billboard

            // Vertex-to-fragment structure
            struct ParticleDepthV2F {
                float4 pos        : SV_POSITION; // Clip-space position
                float2 uv         : TEXCOORD0;   // Quad UV
                float3 posWorld   : TEXCOORD1;   // World-space position (centre of vertex)
            };

            // Vertex shader: build camera-facing quad for each particle
            ParticleDepthV2F vert(appdata_base v, uint instanceID : SV_InstanceID) {
                ParticleDepthV2F o;
                
                float3 worldCentre = Positions[instanceID];
                float3 vertOffset  = v.vertex * scale * 2.0;

                // Camera orientation vectors (world space)
                float3 camUp    = unity_CameraToWorld._m01_m11_m21;
                float3 camRight = unity_CameraToWorld._m00_m10_m20;

                // Position billboard vertex in world space
                float3 vertPosWorld = worldCentre + camRight * vertOffset.x + camUp * vertOffset.y;

                o.pos      = mul(UNITY_MATRIX_VP, float4(vertPosWorld, 1.0));
                o.posWorld = vertPosWorld;
                o.uv       = v.texcoord;

                return o;
            }

            // Convert linear depth (world units from camera) to Unity's non-linear depth buffer value
            float linearDepthToUnityDepth(float linearDepth) {
                float depth01 = (linearDepth - _ProjectionParams.y) / (_ProjectionParams.z - _ProjectionParams.y);
                return (1.0 - (depth01 * _ZBufferParams.y)) / (depth01 * _ZBufferParams.x);
            }

            // Fragment shader: write per-pixel depth of spherical particle
            float4 frag(ParticleDepthV2F i, out float Depth : SV_Depth) : SV_Target {
                // Discard fragments outside particle circle (in quad UV space)
                float2 centreOffset = (i.uv - 0.5) * 2.0;
                float sqrDst        = dot(centreOffset, centreOffset);
                if (sqrDst > 1.0) discard;

                // Reconstruct sphere depth from circle UV
                float z        = sqrt(1.0 - sqrDst);
                float camSpaceZ = abs(mul(unity_MatrixV, float4(i.posWorld, 1.0)).z);
                float dcam      = length(i.posWorld - _WorldSpaceCameraPos);

                // Push depth towards camera based on sphere surface
                float linearDepth = dcam - z * scale;
                Depth = linearDepthToUnityDepth(linearDepth);
                
                // Also output linear depth to colour for optional debug
                return linearDepth;
            }

            ENDCG
        }
    }
}
------------------------------

 -- ParticleThin.shader --
Shader "Fluid/ParticleThickness" {
	SubShader {

		Tags { "Queue"="Transparent" }
		ZWrite Off
		ZTest LEqual
		Cull Off
		Blend One One

		Pass {

			CGPROGRAM

			#pragma vertex vertexShader
			#pragma fragment fragmentShader
			#pragma target 4.5
			#include "UnityCG.cginc"
			
			StructuredBuffer<float3> positions;   // World-space particle centres
			float scale;                          // Half-extent of quad from centre
			static const float CONTRIBUTION = 0.1; // Additive thickness per particle

			struct V2f
			{
				float4 pos : SV_POSITION;
				float2 uv : TEXCOORD0;
			};

			V2f vertexShader(appdata_base v, uint instanceID : SV_InstanceID)
			{
				V2f o;
				// Fetch particle centre from the GPU buffer
				float3 worldCentre = positions[instanceID];
				float3 vertOffset = v.vertex * scale * 2;
				float3 camUp = unity_CameraToWorld._m01_m11_m21;
				float3 camRight = unity_CameraToWorld._m00_m10_m20;
				float3 vertPosWorld = worldCentre + camRight * vertOffset.x + camUp * vertOffset.y;
				o.pos = mul(UNITY_MATRIX_VP, float4(vertPosWorld, 1));
				o.uv = v.texcoord;

				return o;
			}

			float4 fragmentShader(V2f i) : SV_Target
			{
				// Compute distance from quad centre in texture space
				float2 centreOffset = (i.uv - 0.5) * 2;
				float sqrDst = dot(centreOffset, centreOffset);
				// Discard fragments outside the unit circle to create a smooth disc
				if (sqrDst >= 1) discard;

				// Write constant thickness contribution (additive blending)
				return CONTRIBUTION;
			}

			ENDCG
		}
	}
}
------------------------------

 -- SmoothPreparer.shader --
Shader "Fluid/SmoothThickPrepare"
{
    // Texture placeholder kept for consistency (not used directly)
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }

    SubShader
    {
        // Screen-space utility pass: culls nothing, writes no depth, always passes depth test
        Cull Off
        ZWrite Off
        ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vertexShader
            #pragma fragment fragmentShader

            #include "UnityCG.cginc"

            // Vertex data supplied by the full-screen quad
            struct AppData
            {
                float4 vertex : POSITION;
                float2 uv     : TEXCOORD0;
            };

            // Data passed from the vertex shader to the fragment shader
            struct V2F
            {
                float2 uv     : TEXCOORD0;
                float4 pos    : SV_POSITION;
            };

            // Vertex shader : transforms position to clip space, forwards UVs
            V2F vertexShader(AppData v)
            {
                V2F o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv  = v.uv;
                return o;
            }

            sampler2D Depth;      // Raw/filtered scene depth (R channel)
            sampler2D Thick;      // Smoothed particle thickness (R channel)

            // Fragment shader : packs depth + thickness into a single RGBA output
            //  R = depth, G = thickness, B = thickness (duplicate for later use), A = depth
            float4 fragmentShader(V2F i) : SV_Target
            {
                float  depth     = tex2D(Depth,  i.uv).r;
                float  thickness = tex2D(Thick,  i.uv).r;

                return float4(depth, thickness, thickness, depth);
            }
            ENDCG
        }
    }
}

------------------------------

 -- Bilateral1D.cs --
using UnityEngine;
using UnityEngine.Rendering;

namespace Project.Fluid.Rendering
{
	public class BilateralSmoother1D
	{
		Material _filterMat;
		readonly int _tempRtId;

		public BilateralSmoother1D()
		{
			_tempRtId = Shader.PropertyToID("Blt1D_TempRT");
		}

		public void Apply(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralSmoother2D.BilateralFilterSettings settings)
		{
			Apply(cmd, src, dst, desc, settings, Vector3.one);
		}

		public void Apply(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralSmoother2D.BilateralFilterSettings settings, Vector3 mask)
		{
			EnsureMaterial();

			_filterMat.SetFloat("_radiusMeters", settings.worldRadius);
			_filterMat.SetInt("_maxPixelRadius", settings.maxScreenSpaceSize);
			_filterMat.SetFloat("_gaussStrength", settings.strength);
			_filterMat.SetFloat("_depthDifferenceScale", settings.diffStrength);
			_filterMat.SetVector("_channelMask", mask);

			cmd.GetTemporaryRT(_tempRtId, desc);

			for (int i = 0; i < settings.iterations; i++)
			{
				// horizontal pass
				cmd.Blit(src, _tempRtId, _filterMat, 0);
				// vertical pass
				cmd.Blit(_tempRtId, dst, _filterMat, 1);
				src = dst;
			}

			cmd.ReleaseTemporaryRT(_tempRtId);
		}

		void EnsureMaterial()
		{
			if (_filterMat == null)
			{
				_filterMat = new Material(Shader.Find("Hidden/BilateralFilter1D"));
			}
		}
	}

	public class Bilateral1D : BilateralSmoother1D {
		public void Smooth(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralSmoother2D.BilateralFilterSettings settings) {
			Apply(cmd, src, dst, desc, settings);
		}
		public void Smooth(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralSmoother2D.BilateralFilterSettings settings, Vector3 mask) {
			Apply(cmd, src, dst, desc, settings, mask);
		}

		// Overloads to accept the 2D wrapper settings struct used elsewhere
		public void Smooth(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralSmooth2D.BilateralFilterSettings settings) {
		    // Map to base struct
		    BilateralSmoother2D.BilateralFilterSettings mapped;
		    mapped.worldRadius = settings.worldRadius != 0 ? settings.worldRadius : settings.WorldRadius;
		    mapped.maxScreenSpaceSize = settings.maxScreenSpaceSize != 0 ? settings.maxScreenSpaceSize : settings.MaxScreenSpaceSize;
		    mapped.strength = settings.strength != 0 ? settings.strength : settings.Strength;
		    mapped.diffStrength = settings.diffStrength != 0 ? settings.diffStrength : settings.DiffStrength;
		    mapped.iterations = settings.iterations != 0 ? settings.iterations : settings.Iterations;
		    Apply(cmd, src, dst, desc, mapped);
		}
		public void Smooth(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralSmooth2D.BilateralFilterSettings settings, Vector3 mask) {
		    BilateralSmoother2D.BilateralFilterSettings mapped;
		    mapped.worldRadius = settings.worldRadius != 0 ? settings.worldRadius : settings.WorldRadius;
		    mapped.maxScreenSpaceSize = settings.maxScreenSpaceSize != 0 ? settings.maxScreenSpaceSize : settings.MaxScreenSpaceSize;
		    mapped.strength = settings.strength != 0 ? settings.strength : settings.Strength;
		    mapped.diffStrength = settings.diffStrength != 0 ? settings.diffStrength : settings.DiffStrength;
		    mapped.iterations = settings.iterations != 0 ? settings.iterations : settings.Iterations;
		    Apply(cmd, src, dst, desc, mapped, mask);
		}
	}
}
------------------------------

 -- Bilateral1D.shader --
Shader "Hidden/BilateralFilter1D"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
            #include "BilateralPass.hlsl"

            float4 frag (V2F i) : SV_Target
            {
                return calculateBlur1D(i.uv, float2(1, 0));
            }

            ENDCG
        }
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
            #include "BilateralPass.hlsl"

            float4 frag (V2F i) : SV_Target
            {
                return calculateBlur1D(i.uv, float2(0, 1));
            }

            ENDCG
        }
    }
}

------------------------------

 -- BilateralStep.hlsl --
#include <UnityShaderVariables.cginc>

struct AppData
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;
};

struct V2F
{
    float2 uv : TEXCOORD0;
    float4 vertex : SV_POSITION;
};

V2F vert(AppData v)
{
    V2F o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv = v.uv;
    return o;
}

sampler2D _MainTex;
float4 _MainTex_TexelSize;

// Updated uniform names (preferred)
float _radiusMeters;
int   _maxPixelRadius;
float _gaussStrength;
float _depthDifferenceScale;
float3 _channelMask;

// Legacy names kept for compatibility (not assigned by script anymore)
float worldRadius;
int   maxScreenSpaceRadius;
float strength;
float diffStrength;
float3 smoothMask;


float calculate1dGaussianKernel(int x, float sigma)
{
    float c = 2 * sigma * sigma;
    return exp(-x * x / c);
}

float calculateScreenSpaceRadius(float3 viewPoint, float worldRadius, int imageWidth)
{
    // Thanks to Freya Holmér
    float clipW = viewPoint.z;
    float proj = UNITY_MATRIX_P._m00;
    float pxPerMeter = (imageWidth * proj) / (2 * clipW);
    return abs(pxPerMeter * worldRadius);
}

// Calculate the number of pixels covered by a world-space radius at given dst from camera
float calculateScreenSpaceRadius(float worldRadius, float depth, int imageWidth)
{
    float widthScale = UNITY_MATRIX_P._m00; // smaller values correspond to higher fov (objects appear smaller)
    float pxPerMeter = (imageWidth * widthScale) / (2 * depth);
    return abs(pxPerMeter) * worldRadius;
}

float4 viewPos(float2 uv, float depth)
{
    float3 origin = 0;
    float3 viewVector = mul(unity_CameraInvProjection, float4(uv.xy * 2 - 1, 0, -1));
    float3 dir = normalize(viewVector);
    return float4(origin + dir * depth, depth);
}

float4 calculateBlur1D(float2 uv, float2 dir)
{
    float4 original = tex2D(_MainTex, uv);
    float depth = original.a;
    
    // Calculate screenspace radius
    float3 viewPosition = viewPos(uv, depth);

    // Prefer new uniforms but fall back to legacy if zero
    float rMeters = _radiusMeters != 0 ? _radiusMeters : worldRadius;
    int maxPx = _maxPixelRadius != 0 ? _maxPixelRadius : maxScreenSpaceRadius;
    float gStrength = _gaussStrength != 0 ? _gaussStrength : strength;
    float dScale = _depthDifferenceScale != 0 ? _depthDifferenceScale : diffStrength;
    float3 mask = (_channelMask.x + _channelMask.y + _channelMask.z) != 0 ? _channelMask : smoothMask;

    float radiusFloat = calculateScreenSpaceRadius(rMeters, depth, _MainTex_TexelSize.z);
    int radius = ceil(radiusFloat);
    if (radius <= 1 && rMeters > 0) radius = 2;
    radius = min(maxPx, radius);
    float fR = max(0, radius - radiusFloat); // use fractional part of radius in sigma calc to avoid harsh boundaries where radius integer changes
    float sigma = max(0.0000001, (radius - fR) / (6 * max(0.001, gStrength)));
    
    float4 sum = 0;
    float wSum = 0;
    float2 texelDelta = _MainTex_TexelSize.xy * dir;

    for (int x = -radius; x <= radius; x++)
    {
        float w = calculate1dGaussianKernel(x, sigma);
        float2 uv2 = uv + texelDelta * x;
        float4 sample = tex2Dlod(_MainTex, float4(uv2, 0, 0));

        float centreDiff = original.a - sample.a;
        float diffWeight = exp(-centreDiff * centreDiff * dScale);

        float sampleWeight = w * diffWeight;
        sum += sample * sampleWeight;
        wSum += sampleWeight;
    }

    if (wSum > 0)
    {
        sum /= wSum;

    }
    return float4(lerp(original.rgb, sum.rgb, mask), depth);
}
------------------------------

 -- Bilateral2D.cs --
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Serialization;

namespace Project.Fluid.Rendering
{
	/// <summary>
	/// Performs a separable bilateral smoothing pass on a 2D texture.
	/// </summary>
	public class BilateralSmoother2D
	{
		// Material used for filtering
		Material _filterMat;

		// Unique id for the temporary render target
		readonly int _tempRtId;

		public BilateralSmoother2D()
		{
			_tempRtId = Shader.PropertyToID("BltSmoother_TempRT");
		}

		// Public entry point – smooth with default full-strength mask (Vector3.one)
		public void Apply(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralFilterSettings settings)
		{
			Apply(cmd, src, dst, desc, settings, Vector3.one);
		}

		// Public entry point – smooth using a per-channel mask
		public void Apply(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralFilterSettings settings, Vector3 mask)
		{
			EnsureMaterial();

			PopulateShaderUniforms(mask, settings);

			cmd.GetTemporaryRT(_tempRtId, desc);

			var readTarget = src;
			RenderTargetIdentifier writeTarget = new RenderTargetIdentifier(_tempRtId);

			for (int iteration = 0; iteration < settings.iterations; iteration++)
			{
				ProcessIteration(cmd, ref readTarget, ref writeTarget);
			}

			cmd.Blit(readTarget, dst);
			cmd.ReleaseTemporaryRT(_tempRtId);
		}

		// Run a single bilateral filter iteration
		void ProcessIteration(CommandBuffer cmd, ref RenderTargetIdentifier read, ref RenderTargetIdentifier write)
		{
			cmd.Blit(read, write, _filterMat);
			// swap for next pass
			(read, write) = (write, read);
		}

		// Make sure the material exists and is wired up to the hidden shader
		void EnsureMaterial()
		{
			if (_filterMat == null)
			{
				_filterMat = new Material(Shader.Find("Hidden/BilateralFilter2D"));
			}
		}

		// Push user-defined settings down to the shader as uniform values
		void PopulateShaderUniforms(Vector3 mask, BilateralFilterSettings s)
		{
			_filterMat.SetFloat("_radiusMeters", s.worldRadius);
			_filterMat.SetInt("_maxPixelRadius", s.maxScreenSpaceSize);
			_filterMat.SetFloat("_gaussStrength", s.strength);
			_filterMat.SetFloat("_depthDifferenceScale", s.diffStrength);
			_filterMat.SetVector("_channelMask", mask);
		}

		// Exposed parameters for the filter. All public fields are lowercase to satisfy the user's style guideline.
		[System.Serializable]
		public struct BilateralFilterSettings
		{
			[FormerlySerializedAs("WorldRadius")] public float worldRadius;
			[FormerlySerializedAs("MaxScreenSpaceSize")] public int maxScreenSpaceSize;

			[Range(0, 1)] public float strength;
			public float diffStrength;
			public int iterations;
		}
	}

	public class BilateralSmooth2D : BilateralSmoother2D {
		public new struct BilateralFilterSettings {
			public float worldRadius;
			public int maxScreenSpaceSize;
			[Range(0,1)] public float strength;
			public float diffStrength;
			public int iterations;

			public float WorldRadius;
			public int MaxScreenSpaceSize;
			public float Strength;
			public float DiffStrength;
			public int Iterations;
		}

		public void Smooth(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralFilterSettings settings) {
			// Map legacy struct to base struct
			Project.Fluid.Rendering.BilateralSmoother2D.BilateralFilterSettings mapped;
			mapped.worldRadius = settings.worldRadius != 0 ? settings.worldRadius : settings.WorldRadius;
			mapped.maxScreenSpaceSize = settings.maxScreenSpaceSize != 0 ? settings.maxScreenSpaceSize : settings.MaxScreenSpaceSize;
			mapped.strength = settings.strength != 0 ? settings.strength : settings.Strength;
			mapped.diffStrength = settings.diffStrength != 0 ? settings.diffStrength : settings.DiffStrength;
			mapped.iterations = settings.iterations != 0 ? settings.iterations : settings.Iterations;
			Apply(cmd, src, dst, desc, mapped);
		}

		public void Smooth(CommandBuffer cmd, RenderTargetIdentifier src, RenderTargetIdentifier dst, RenderTextureDescriptor desc, BilateralFilterSettings settings, Vector3 mask) {
			Project.Fluid.Rendering.BilateralSmoother2D.BilateralFilterSettings mapped;
			mapped.worldRadius = settings.worldRadius != 0 ? settings.worldRadius : settings.WorldRadius;
			mapped.maxScreenSpaceSize = settings.maxScreenSpaceSize != 0 ? settings.maxScreenSpaceSize : settings.MaxScreenSpaceSize;
			mapped.strength = settings.strength != 0 ? settings.strength : settings.Strength;
			mapped.diffStrength = settings.diffStrength != 0 ? settings.diffStrength : settings.DiffStrength;
			mapped.iterations = settings.iterations != 0 ? settings.iterations : settings.Iterations;
			Apply(cmd, src, dst, desc, mapped, mask);
		}
	}
}
------------------------------

 -- Bilateral2D.shader --
Shader "Hidden/BilateralFilter2D" 
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct VertexData
            {
                float4 position : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct Interpolators
            {
                float2 uv : TEXCOORD0;
                float4 clipPos : SV_POSITION;
            };

            Interpolators vert (VertexData v)
            {
                Interpolators o;
                o.clipPos = UnityObjectToClipPos(v.position);
                o.uv = v.uv;
                return o;
            }

            sampler2D _MainTex;
            float4 _MainTex_TexelSize; // x = texelWidth, y = texelHeight, z = width, w = height
            float _radiusMeters;          // world-space radius (meters)
            int   _maxPixelRadius;         // clamp radius in pixels
            float _gaussStrength;          // gaussian sigma scale
            float _depthDifferenceScale;   // additional depth-based attenuation
            float3 _channelMask;           // rgb mask – controls channel blending

            // 2-dimensional gaussian falloff
            inline float Gaussian2D(int x, int y, float sigma)
            {
                const float denom = 2.0 * sigma * sigma;
                return exp(-(x * x + y * y) / denom);
            }

            // Converts world radius to pixel radius at the given view-space point
            float WorldRadiusToPixels(float3 viewPoint, float meters, int imageWidth)
            {
                float clipW = viewPoint.z;
                float proj = UNITY_MATRIX_P._m00;
                float pxPerMeter = (imageWidth * proj) / (2.0 * clipW);
                return abs(pxPerMeter * meters);
            }

            // Retrieve view position from depth buffer value
            float3 ReconstructViewPos(float2 uv, float depth)
            {
                float3 origin = 0;
                float3 viewVec = mul(unity_CameraInvProjection, float4(uv * 2.0 - 1.0, 0, -1.0));
                float3 dir = normalize(viewVec);
                return origin + dir * depth;
            }

            float4 frag (Interpolators i) : SV_Target
            {
                float4 centre = tex2D(_MainTex, i.uv);

                // dynamic radius in pixels
                float depth = centre.a;
                float3 viewPos = ReconstructViewPos(i.uv, depth);
                int radius = round(WorldRadiusToPixels(viewPos, _radiusMeters, _MainTex_TexelSize.z));
                radius = min(_maxPixelRadius, radius);

                float sigma = max(1e-7, radius * _gaussStrength);

                float4 sum = 0;
                float weightSum = 0;

                // manual unrolled nested loops for clarity
                for (int dx = -radius; dx <= radius; ++dx)
                {
                    for (int dy = -radius; dy <= radius; ++dy)
                    {
                        float2 offsetUv = i.uv + float2(dx, dy) * _MainTex_TexelSize.xy;
                        float4 sample = tex2Dlod(_MainTex, float4(offsetUv, 0, 0));

                        float w = Gaussian2D(dx, dy, sigma);
                        float depthDelta = centre.a - sample.a;
                        float depthWeight = exp(-depthDelta * depthDelta * _depthDifferenceScale);

                        float finalWeight = w * depthWeight;
                        sum += sample * finalWeight;
                        weightSum += finalWeight;
                    }
                }

                if (weightSum > 0)
                {
                    sum /= weightSum;
                }

                float3 blended = lerp(centre.rgb, sum.rgb, _channelMask);
                return float4(blended, depth);
            }

            ENDCG
        }
    }
}

------------------------------

 -- GaussBlend.shader --
//  A separable Gaussian blur shader comprising two passes (horizontal & vertical).
//  The heavy-lifting is done in GaussPass.hlsl; this file simply wires the passes
//  into Unity’s render pipeline.

Shader "Hidden/GaussSmooth"
{  
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
    }
    SubShader
    {
        Cull Off ZWrite Off ZTest Always

        Pass
        {
            CGPROGRAM
            #pragma fragment frag
            #pragma vertex vert

            #include "UnityCG.cginc"
            #include "GaussPass.hlsl"
            
           
            float4 frag (V2F i) : SV_Target
            {
                return calculateBlur1D(i.uv, float2(1, 0));
            }

            ENDCG
        }
         // Vertical blur (kernel direction 0,1)
         Pass
        {
            CGPROGRAM
            #pragma fragment frag
            #pragma vertex vert

            #include "UnityCG.cginc"
            #include "GaussPass.hlsl"
           
            float4 frag (V2F i) : SV_Target
            {
                return calculateBlur1D(i.uv, float2(0, 1));
            }

            ENDCG
        }
      
    }
}

------------------------------

 -- GaussBlur.cs --
using UnityEngine;
using UnityEngine.Rendering;

namespace Project.Fluid.Rendering
{
    public class GaussBlur
    {
        // Reusable material instance used for the blur passes
        Material _material;

        // ID for the temporary render-target used during the two-pass blur
        readonly int _firstPassRT;

        public GaussBlur()
        {
            _firstPassRT = Shader.PropertyToID("GaussSmooth_FirstPassRT_ID");
        }

        /// <summary>
        /// Applies a separable two-pass Gaussian blur to <paramref name="source"/> and stores the
        /// result in <paramref name="target"/>.
        /// </summary>
        /// <remarks>
        /// This overload uses a <see cref="Vector3.one"/> mask to apply the blur equally to all
        /// colour channels.
        /// </remarks>
        public void Smooth(CommandBuffer commandBuffer, RenderTargetIdentifier source, RenderTargetIdentifier target, RenderTextureDescriptor descriptor, GaussianBlurSettings settings)
        {
            Smooth(commandBuffer, source, target, descriptor, settings, Vector3.one);
        }

        /// <summary>
        /// Applies a separable two-pass Gaussian blur to <paramref name="source"/> and stores the
        /// result in <paramref name="target"/>.
        /// </summary>
        public void Smooth(CommandBuffer commandBuffer, RenderTargetIdentifier source, RenderTargetIdentifier target, RenderTextureDescriptor descriptor, GaussianBlurSettings settings, Vector3 smoothMask)
        {
            EnsureMaterial();
            ApplyMaterialSettings(settings, smoothMask);
            ExecuteBlur(commandBuffer, source, target, descriptor, settings.iterations);
        }

        #region Private helpers

        void EnsureMaterial()
        {
            if (_material == null)
            {
                _material = new Material(Shader.Find("Hidden/GaussSmooth"));
            }
        }

        void ApplyMaterialSettings(GaussianBlurSettings settings, Vector3 smoothMask)
        {
            _material.SetFloat("radius", settings.radius);
            _material.SetInt("maxScreenSpaceRadius", settings.maxScreenSpaceRadius);
            _material.SetFloat("strength", settings.strength);
            _material.SetVector("smoothMask", smoothMask);
            _material.SetInt("useWorldSpaceRadius", settings.useWorldSpaceRadius ? 1 : 0);
        }

        void ExecuteBlur(CommandBuffer commandBuffer, RenderTargetIdentifier source, RenderTargetIdentifier target, RenderTextureDescriptor descriptor, int iterationCount)
        {
            // Allocate a temporary texture for the horizontal and vertical passes.
            commandBuffer.GetTemporaryRT(_firstPassRT, descriptor);

            for (int iteration = 0; iteration < iterationCount; iteration++)
            {
                ApplyGaussianIteration(commandBuffer, ref source, target);
            }

            commandBuffer.ReleaseTemporaryRT(_firstPassRT);
        }

        void ApplyGaussianIteration(CommandBuffer commandBuffer, ref RenderTargetIdentifier source, RenderTargetIdentifier target)
        {
            // Horizontal pass (kernel direction 1,0)
            commandBuffer.Blit(source, _firstPassRT, _material, 0);
            // Vertical pass (kernel direction 0,1)
            commandBuffer.Blit(_firstPassRT, target, _material, 1);
            // Feed the output back as input for the next iteration
            source = target;
        }

        #endregion

        [System.Serializable]
        public struct GaussianBlurSettings
        {
            public bool useWorldSpaceRadius;
            public float radius;
            public int maxScreenSpaceRadius;
            [Range(0, 1)] public float strength;
            public int iterations;
        }

    }
}
------------------------------

 -- GaussStep.hlsl --
// struct appdata
// {
//     float4 vertex : POSITION;
//     float2 uv : TEXCOORD0;
// };

// struct v2f
// {
//     float2 uv : TEXCOORD0;
//     float4 vertex : SV_POSITION;
// };

// v2f vert(appdata v)
// {
//     v2f o;
//     o.vertex = UnityObjectToClipPos(v.vertex);
//     o.uv = v.uv;
//     return o;
// }

struct AppData
{
    float4 vertex : POSITION;
    float2 uv : TEXCOORD0;
};

struct V2F
{
    float2 uv : TEXCOORD0;
    float4 vertex : SV_POSITION;
};

V2F vert(AppData v)
{
    V2F o;
    o.vertex = UnityObjectToClipPos(v.vertex);
    o.uv = v.uv;
    return o;
}

sampler2D _MainTex;
float4 _MainTex_TexelSize;
float radius;
int useWorldSpaceRadius;
int maxScreenSpaceRadius;
float strength;
float3 smoothMask;

// Returns the gaussian weight for the given offset (in pixels) and sigma.
float gaussianWeight(int pixelOffset, float sigma)
{
    const float denominator = 2 * sigma * sigma;          // Normalisation factor
    return exp(-pixelOffset * pixelOffset / denominator); // 1-D gaussian
}

// Converts a world-space blur radius to its equivalent in screen-space pixels.
float screenSpaceRadius(float worldRadius, float depth, int imageWidth)
{
    // Derivation courtesy of Freya Holmer — see: x.com/FreyaHolmer/status/1820157167682388210
    float widthScale  = UNITY_MATRIX_P._m00;               // Smaller values = larger FOV
    float pxPerMeter  = (imageWidth * widthScale) / (2 * depth);
    return abs(pxPerMeter) * worldRadius;
}

// Reconstruct a view-space position from normalised screen UV coordinates and depth.
float4 reconstructViewPos(float2 uv, float depth)
{
    float3 origin      = 0;
    float3 viewVector  = mul(unity_CameraInvProjection, float4(uv.xy * 2 - 1, 0, -1));
    float3 direction   = normalize(viewVector);
    return float4(origin + direction * depth, depth);
}

// Calculates the effective blur radius (in integer pixels) and the sigma value
// that will be used for the gaussian weights.
void calcRadiusAndSigma(out int radiusPixels, out float sigma, float depth)
{
    radiusPixels = ceil(radius);
    sigma        = max(1e-7, radius / (6 * max(0.01, strength)));

    if (useWorldSpaceRadius == 1)
    {
        float screenRadius = screenSpaceRadius(radius, depth, _MainTex_TexelSize.z);

        // Avoid discontinuities where the radius integer changes.
        if (radiusPixels <= 1 && radius > 0) radius = 2;

        radiusPixels = min(maxScreenSpaceRadius, radius);

        float fractional = max(0, radius - screenRadius);
        sigma            = max(1e-7, (radius - fractional) / (6 * max(0.001, strength)));
    }
}

// Performs the actual 1-D blur along a given axis.
float3 blur1D(float2 uv, float2 axis, int radiusPixels, float sigma)
{
    float3 colourSum = 0;
    float  weightSum = 0;

    const float2 texelStep = _MainTex_TexelSize.xy * axis;

    for (int offset = -radiusPixels; offset <= radiusPixels; offset++)
    {
        const float2 sampleUv = uv + texelStep * offset;
        float4 sampledPixel  = tex2Dlod(_MainTex, float4(sampleUv, 0, 0));

        // Discard sky/background samples
        if (sampledPixel.a < 10000)
        {
            float weight = gaussianWeight(offset, sigma);
            colourSum += sampledPixel.rgb * weight;
            weightSum += weight;
        }
    }

    return colourSum / weightSum;
}

// Main entry point called by the fragment shader.
float4 calculateBlur1D(float2 uv, float2 axis)
{
    const float4 originalSample = tex2D(_MainTex, uv);
    const float  originalDepth  = originalSample.a;

    // Determine blur radius and sigma for this pixel
    int   radiusPixels;
    float sigma;
    calcRadiusAndSigma(radiusPixels, sigma, originalDepth);

    // Accumulate samples
    float3 blurredColour = blur1D(uv, axis, radiusPixels, sigma);

    // Blend between original and blurred colour per channel using smoothMask
    return float4(lerp(originalSample.rgb, blurredColour, smoothMask), originalDepth);
}

------------------------------

 -- FluidRender.cs --
using Project.Helpers;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Experimental.Rendering;
using Project.Fluid.Simulation;

namespace Project.Fluid.Rendering
{
	public class FluidRender : MonoBehaviour
	{
		[Header("Main Settings")] public bool useFullSizeThicknessTex;
		public Vector3 extinctionCoefficients;
		public float extinctionMultiplier;
		public float depthParticleSize;
		public float thicknessParticleScale;
		public float refractionMultiplier;
		public Vector3 testParams;

		[Header("Smoothing Settings")] public BlurType smoothType;
		public BilateralSmooth2D.BilateralFilterSettings bilateralSettings;
		public GaussBlur.GaussianBlurSettings gaussSmoothSettings;

		[Header("Environment")] public GaussBlur.GaussianBlurSettings shadowSmoothSettings;
		public EnvironmentSettings environmentSettings;

		[Header("Debug Settings")] public DisplayMode displayMode;
		public float depthDisplayScale;
		public float thicknessDisplayScale;

		[Header("References")] public Shader renderA;
		public Shader depthDownsampleCopyShader;
		public Shader depthShader;
		public Shader normalShader;
		public Shader thicknessShader;
		public Shader smoothThickPrepareShader;
		public Simulation3D sim;
		public Camera shadowCam;
		public Light sun;
		public FoamTrial foamTest;

		private DisplayMode _displayModeOld;
		private Mesh _quadMesh;
		private Material _matDepth;
		private Material _matThickness;
		private Material _matNormal;
		private Material _matComposite;
		private Material _smoothPrepareMat;
		private Material _depthDownsampleCopyMat;
		private ComputeBuffer _argsBuffer;

		private RenderTexture _compRt;
		private RenderTexture _depthRt;
		private RenderTexture _normalRt;
		private RenderTexture _shadowRt;
		private RenderTexture _foamRt;
		private RenderTexture _thicknessRt;

		private CommandBuffer _cmd;
		private CommandBuffer _shadowCmd;

		private Bilateral1D _bilateral1D = new();
		private BilateralSmooth2D _bilateral2D = new();
		private GaussBlur _gaussSmooth = new();

		private void Update()
		{
			Init();
			RenderCamSetup();
			ShadowCamSetup();
			BuildCommands();
			UpdateSettings();

			HandleDebugDisplayInput();
		}

		private void BuildCommands()
		{
			BuildShadowCommands();
			BuildRenderCommands();
		}

		private void BuildShadowCommands()
		{
			_shadowCmd.Clear();
			_shadowCmd.SetRenderTarget(_shadowRt);
			_shadowCmd.ClearRenderTarget(true, true, Color.black);
			_shadowCmd.DrawMeshInstancedIndirect(_quadMesh, 0, _matThickness, 0, _argsBuffer);
			_gaussSmooth.Smooth(_shadowCmd, _shadowRt, _shadowRt, _shadowRt.descriptor, shadowSmoothSettings, Vector3.one);
		}

		private void BuildRenderCommands()
		{
			_cmd.Clear();
			RenderFoamAndSpray();
			RenderParticleDepth();
			RenderParticleThickness();
			PackThicknessAndDepth();
			ApplySmoothing();
			ReconstructNormals();
			CompositeToScreen();
		}

		private void RenderFoamAndSpray()
		{
			if (foamTest == null) return;
			_cmd.SetRenderTarget(_foamRt);
			float depthClearVal = SystemInfo.usesReversedZBuffer ? 0 : 1;
			_cmd.ClearRenderTarget(true, true, new Color(0, depthClearVal, 0, 0));
			foamTest.RenderWithCmdBuffer(_cmd);
		}

		private void RenderParticleDepth()
		{
			_cmd.SetRenderTarget(_depthRt);
			_cmd.ClearRenderTarget(true, true, Color.white * 10000000, 1);
			_cmd.DrawMeshInstancedIndirect(_quadMesh, 0, _matDepth, 0, _argsBuffer);
		}

		private void RenderParticleThickness()
		{
			_cmd.SetRenderTarget(_thicknessRt);
			_cmd.Blit(_foamRt, _thicknessRt, _depthDownsampleCopyMat);
			_cmd.DrawMeshInstancedIndirect(_quadMesh, 0, _matThickness, 0, _argsBuffer);
		}

		private void PackThicknessAndDepth()
		{
			_cmd.Blit(null, _compRt, _smoothPrepareMat);
		}

		private void ApplySmoothing()
		{
			ApplyActiveSmoothingType(_cmd, _compRt, _compRt, _compRt.descriptor, new Vector3(1, 1, 0));
		}

		private void ReconstructNormals()
		{
			_cmd.Blit(_compRt, _normalRt, _matNormal);
		}

		private void CompositeToScreen()
		{
			_cmd.Blit(_foamRt, BuiltinRenderTextureType.CameraTarget, _matComposite);
		}

		private void Init()
		{
			if (sim == null)
			{
				sim = FindObjectOfType<Simulation3D>();
				if (sim == null) return; // simulation not ready yet
			}
			if (foamTest == null)
			{
				foamTest = FindObjectOfType<FoamTrial>();
			}
			if (_cmd == null) { _cmd = new CommandBuffer { name = "Fluid Render Commands" }; }
			if (_shadowCmd == null) { _shadowCmd = new CommandBuffer { name = "Fluid Shadow Commands" }; }
			if (!_quadMesh) 
				_quadMesh = MeshBuilder.GenerateQuadMesh();
			
			ComputeHelper.CreateArgsBuffer(ref _argsBuffer, _quadMesh, sim.positionBuffer.count);
			InitTextures();
			InitMaterials();
		}

		private void InitMaterials()
		{
			if (!_depthDownsampleCopyMat) _depthDownsampleCopyMat = new Material(depthDownsampleCopyShader);
			if (!_matDepth) _matDepth = new Material(depthShader);
			if (!_matNormal) _matNormal = new Material(normalShader);
			if (!_matThickness) _matThickness = new Material(thicknessShader);
			if (!_smoothPrepareMat) _smoothPrepareMat = new Material(smoothThickPrepareShader);
			if (!_matComposite) _matComposite = new Material(renderA);
		}

		private void InitTextures()
		{
			int width = Screen.width;
			int height = Screen.height;
			float aspect = height / (float)width;
			int thicknessTexMaxWidth = Mathf.Min(1280, width);
			int thicknessTexMaxHeight = Mathf.Min((int)(1280 * aspect), height);
			int thicknessTexWidth = Mathf.Max(thicknessTexMaxWidth, width / 2);
			int thicknessTexHeight = Mathf.Max(thicknessTexMaxHeight, height / 2);

			if (useFullSizeThicknessTex)
			{
				thicknessTexWidth = width;
				thicknessTexHeight = height;
			}

			// Shadow texture size
			const int shadowTexSizeReduction = 4;
			int shadowTexWidth = width / shadowTexSizeReduction;
			int shadowTexHeight = height / shadowTexSizeReduction;
			GraphicsFormat fmtRGBA = GraphicsFormat.R32G32B32A32_SFloat;
			GraphicsFormat fmtR = GraphicsFormat.R32_SFloat;
			ComputeHelper.CreateRenderTexture(ref _depthRt, width, height, FilterMode.Bilinear, fmtR, depthMode: DepthMode.Depth16);
			ComputeHelper.CreateRenderTexture(ref _thicknessRt, thicknessTexWidth, thicknessTexHeight, FilterMode.Bilinear, fmtR, depthMode: DepthMode.Depth16);
			ComputeHelper.CreateRenderTexture(ref _normalRt, width, height, FilterMode.Bilinear, fmtRGBA, depthMode: DepthMode.None);
			ComputeHelper.CreateRenderTexture(ref _compRt, width, height, FilterMode.Bilinear, fmtRGBA, depthMode: DepthMode.None);
			ComputeHelper.CreateRenderTexture(ref _shadowRt, shadowTexWidth, shadowTexHeight, FilterMode.Bilinear, fmtR, depthMode: DepthMode.None);
			ComputeHelper.CreateRenderTexture(ref _foamRt, width, height, FilterMode.Bilinear, fmtRGBA, depthMode: DepthMode.Depth16);

			}

		private void ApplyActiveSmoothingType(CommandBuffer buffer, RenderTargetIdentifier src, RenderTargetIdentifier target, RenderTextureDescriptor desc, Vector3 smoothMask)
		{
			if (smoothType == BlurType.Bilateral1D)
				_bilateral1D.Smooth(buffer, src, target, desc, bilateralSettings, smoothMask);
			else if (smoothType == BlurType.Bilateral2D)
				_bilateral2D.Smooth(buffer, src, target, desc, bilateralSettings, smoothMask);
			else if (smoothType == BlurType.Gaussian)
				_gaussSmooth.Smooth(buffer, src, target, desc, gaussSmoothSettings, smoothMask);
		}

		private float FrameBoundsOrtho(Vector3 boundsSize, Matrix4x4 worldToView)
		{
			Vector3 halfSize = boundsSize * 0.5f;
			float maxX = 0;
			float maxY = 0;

			for (int i = 0; i < 8; i++)
			{
				Vector3 corner = new Vector3(
					(i & 1) == 0 ? -halfSize.x : halfSize.x,
					(i & 2) == 0 ? -halfSize.y : halfSize.y,
					(i & 4) == 0 ? -halfSize.z : halfSize.z
				);

				Vector3 viewCorner = worldToView.MultiplyPoint(corner);
				maxX = Mathf.Max(maxX, Mathf.Abs(viewCorner.x));
				maxY = Mathf.Max(maxY, Mathf.Abs(viewCorner.y));
			}

			float aspect = Screen.height / (float)Screen.width;
			float targetOrtho = Mathf.Max(maxY, maxX * aspect);
			return targetOrtho;
		}

		private void RenderCamSetup()
		{
			if (_cmd == null)
			{
				_cmd = new();
				_cmd.name = "Fluid Render Commands";
			}

			Camera.main.RemoveAllCommandBuffers();
			Camera.main.AddCommandBuffer(CameraEvent.AfterEverything, _cmd);
			Camera.main.depthTextureMode = DepthTextureMode.Depth;
		}

		private void ShadowCamSetup()
		{
			if (shadowCam == null || sun == null) return;

			if (_shadowCmd == null)
			{
				_shadowCmd = new();
				_shadowCmd.name = "Fluid Shadow Render Commands";
			}

			shadowCam.RemoveAllCommandBuffers();
			shadowCam.AddCommandBuffer(CameraEvent.BeforeForwardOpaque, _shadowCmd);

			Vector3 dirToSun = -sun.transform.forward;
			shadowCam.transform.position = dirToSun * 50;
			shadowCam.transform.rotation = sun.transform.rotation;
			shadowCam.orthographicSize = FrameBoundsOrtho(sim.Scale, shadowCam.worldToCameraMatrix) + 0.5f;
		}


		private void UpdateSettings()
		{
			_smoothPrepareMat.SetTexture("Depth", _depthRt);
			_smoothPrepareMat.SetTexture("Thick", _thicknessRt);
			_matThickness.SetBuffer("positions", sim.positionBuffer);
			_matThickness.SetFloat("scale", thicknessParticleScale);
			_matDepth.SetBuffer("Positions", sim.positionBuffer);
			_matDepth.SetFloat("scale", depthParticleSize);
			_matNormal.SetInt("useSmoothedDepth", Input.GetKey(KeyCode.LeftControl) ? 0 : 1);

			_matComposite.SetInt("debugDisplayMode", (int)displayMode);
			_matComposite.SetTexture("Comp", _compRt);
			_matComposite.SetTexture("Normals", _normalRt);
			_matComposite.SetTexture("ShadowMap", _shadowRt);
			
			_matComposite.SetVector("testParams", testParams);
			_matComposite.SetVector("extinctionCoefficients", extinctionCoefficients * extinctionMultiplier);
			_matComposite.SetVector("boundsSize", sim.Scale);
			_matComposite.SetFloat("refractionMultiplier", refractionMultiplier);

			_matComposite.SetMatrix("shadowVP", GL.GetGPUProjectionMatrix(shadowCam.projectionMatrix, false) * shadowCam.worldToCameraMatrix);
			_matComposite.SetVector("dirToSun", -sun.transform.forward);
			_matComposite.SetFloat("depthDisplayScale", depthDisplayScale);
			_matComposite.SetFloat("thicknessDisplayScale", thicknessDisplayScale);
			_matComposite.SetBuffer("foamCountBuffer", sim.foamCountBuffer);
			_matComposite.SetInt("foamMax", sim.foamBuffer.count);
			
			Vector3 floorSize = new Vector3(30, 0.05f, 30);
			float floorHeight = -sim.Scale.y / 2 + sim.transform.position.y - floorSize.y / 2;
			_matComposite.SetVector("floorPos", new Vector3(0, floorHeight, 0));
			_matComposite.SetVector("floorSize", floorSize);
			EnvironmentSettings env = environmentSettings;
			if (env.noiseScale <= 0) env.noiseScale = 3;
			if (env.secondaryNoiseScale <= 0) env.secondaryNoiseScale = env.noiseScale * 0.5f;
			if (env.secondaryNoiseWeight == 0) env.secondaryNoiseWeight = 0.5f;
			if (env.gradientStrength == 0) env.gradientStrength = 1;
			if (env.colorVariation == Vector3.zero) env.colorVariation = new Vector3(0.2f, 0.2f, 0.2f);
			if (env.baseColor.a == 0) env.baseColor = Color.gray;
			
			_matComposite.SetColor("baseColor", env.baseColor);
			_matComposite.SetVector("colorVariation", env.colorVariation);
			_matComposite.SetFloat("noiseScale", env.noiseScale);
			_matComposite.SetFloat("secondaryNoiseScale", env.secondaryNoiseScale);
			_matComposite.SetFloat("secondaryNoiseWeight", env.secondaryNoiseWeight);
			_matComposite.SetColor("cornerColorBL", env.cornerColorBL);
			_matComposite.SetColor("cornerColorBR", env.cornerColorBR);
			_matComposite.SetColor("cornerColorTL", env.cornerColorTL);
			_matComposite.SetColor("cornerColorTR", env.cornerColorTR);
			_matComposite.SetFloat("gradientStrength", env.gradientStrength);
			_matComposite.SetFloat("sunIntensity", environmentSettings.sunIntensity);
			_matComposite.SetFloat("sunInvSize", environmentSettings.sunInvSize);
		}

		private void HandleDebugDisplayInput()
		{
			for (int i = 0; i <= 9; i++)
			{
				if (Input.GetKeyDown(KeyCode.Alpha0 + i))
				{
					displayMode = (DisplayMode)i;
					Debug.Log("Set display mode: " + displayMode);
				}
			}
		}

		[System.Serializable]
		public struct EnvironmentSettings
		{
			public Color baseColor;
			public Vector3 colorVariation;
			public float noiseScale;
			public float secondaryNoiseScale;
			public float secondaryNoiseWeight;
			public Color cornerColorBL;
			public Color cornerColorBR;
			public Color cornerColorTL;
			public Color cornerColorTR;
			public float gradientStrength;
			public float sunIntensity;
			public float sunInvSize;
		}

		public enum DisplayMode
		{
			Composite,
			Depth,
			SmoothDepth,
			Normal,
			Thickness,
			SmoothThickness
		}

		public enum BlurType
		{
			Gaussian,
			Bilateral2D,
			Bilateral1D
		}


		private void OnDestroy()
		{
			ComputeHelper.Release(_argsBuffer);
			ComputeHelper.Release(_depthRt, _thicknessRt, _normalRt, _compRt, _shadowRt, _foamRt);
		}
	}
}
------------------------------

 -- FluidDynamics.compute --
#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel Reorder
#pragma kernel ReorderCopyBack;
#pragma kernel CalculateDensities
#pragma kernel CalculatePressureForce
#pragma kernel CalculateViscosity
#pragma kernel UpdatePositions
#pragma kernel UpdateDensityTexture
#pragma kernel UpdateWhiteParticles
#pragma kernel WhiteParticlePrepareNextFrame;

// Includes
#include "./FluidMath3D.hlsl"
#include "./SpatialHash3D.hlsl"

static const int THREAD_GROUP_SIZE = 256;


// Buffers
RWStructuredBuffer<float3> Positions;
RWStructuredBuffer<float3> PredictedPositions;
RWStructuredBuffer<float3> Velocities;
RWStructuredBuffer<float2> Densities; // Density, Near Density

// Spatial hashing
RWStructuredBuffer<uint> SpatialKeys;
RWStructuredBuffer<uint> SpatialOffsets;
StructuredBuffer<uint> SortedIndices;

RWStructuredBuffer<float3> Debug;

// Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float simTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityStrength;
const float edgeForce;
const float edgeForceDst;
const float3 boundsSize;

const float4x4 localToWorld;
const float4x4 worldToLocal;

const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

// Volume texture settings
RWTexture3D<float> DensityMap;
const uint3 densityMapSize;

struct WhiteParticle
{
    float3 position;
    float3 velocity;
    float remainingLifetime;
    float scale;
};

RWStructuredBuffer<WhiteParticle> WhiteParticles;
RWStructuredBuffer<WhiteParticle> WhiteParticlesCompacted;
// Holds 2 values:
// [0] = ActiveCount: (num particles alive or spawned in at the start of the frame)
// [1] = SurvivorCount: (num particles surviving to the next frame -- copied into compact buffer)
RWStructuredBuffer<uint> WhiteParticleCounters;
const uint MaxWhiteParticleCount;
const float whiteParticleDeltaTime;

const float3 trappedAirParams;
const float2 kineticEnergyParams;
const float bubbleBuoyancy;
const int bubbleClassifyMinNeighbours;
const int sprayClassifyMaxNeighbours;
const float bubbleScale;
const float bubbleScaleChangeSpeed;

float PressureFromDensity(float density)
{
    return (density - targetDensity) * pressureMultiplier;
}

float NearPressureFromDensity(float nearDensity)
{
    return nearDensity * nearPressureMultiplier;
}


float Remap01(float val, float minVal, float maxVal)
{
    return saturate((val - minVal) / (maxVal - minVal));
}

void ResolveCollisions(inout float3 pos, inout float3 vel, float collisionDamping)
{
    // Transform position/velocity to the local space of the bounding box (scale not included)
    float3 posLocal = mul(worldToLocal, float4(pos, 1)).xyz;
    float3 velocityLocal = mul(worldToLocal, float4(vel, 0)).xyz;

    // Calculate distance from box on each axis (negative values are inside box)
    const float3 halfSize = 0.5;
    const float3 edgeDst = halfSize - abs(posLocal);

    // Resolve collisions
    if (edgeDst.x <= 0)
    {
        posLocal.x = halfSize.x * sign(posLocal.x);
        velocityLocal.x *= -1 * collisionDamping;
    }
    if (edgeDst.y <= 0)
    {
        posLocal.y = halfSize.y * sign(posLocal.y);
        velocityLocal.y *= -1 * collisionDamping;
    }
    if (edgeDst.z <= 0)
    {
        posLocal.z = halfSize.z * sign(posLocal.z);
        velocityLocal.z *= -1 * collisionDamping;
    }

    // Transform resolved position/velocity back to world space
    pos = mul(localToWorld, float4(posLocal, 1)).xyz;
    vel = mul(localToWorld, float4(velocityLocal, 0)).xyz;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    // External forces (gravity)
    Velocities[id.x] += float3(0, gravity, 0) * deltaTime;

    // Predict
    PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * 1 / 120.0;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateSpatialHash(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    uint index = id.x;
    int3 cell = GetCell3D(PredictedPositions[index], smoothingRadius);
    uint hash = HashCell3D(cell);
    uint key = KeyFromHash(hash, numParticles);

    SpatialKeys[id.x] = key;
}


RWStructuredBuffer<float3> SortTarget_Positions;
RWStructuredBuffer<float3> SortTarget_PredictedPositions;
RWStructuredBuffer<float3> SortTarget_Velocities;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void Reorder(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;
    uint sortedIndex = SortedIndices[id.x];
    SortTarget_Positions[id.x] = Positions[sortedIndex];
    SortTarget_PredictedPositions[id.x] = PredictedPositions[sortedIndex];
    SortTarget_Velocities[id.x] = Velocities[sortedIndex];
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ReorderCopyBack(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    Positions[id.x] = SortTarget_Positions[id.x];
    PredictedPositions[id.x] = SortTarget_PredictedPositions[id.x];
    Velocities[id.x] = SortTarget_Velocities[id.x];
}

float2 CalculateDensitiesAtPoint(float3 pos)
{
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    float density = 0;
    float nearDensity = 0;

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius)
                continue;

            // Calculate density and near density
            float dst = sqrt(sqrDstToNeighbour);
            density += densityKernel(dst, smoothingRadius);
            nearDensity += nearDensityKernel(dst, smoothingRadius);
        }
    }

    return float2(density, nearDensity);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CalculateDensities(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 pos = PredictedPositions[id.x];
    float2 densities = CalculateDensitiesAtPoint(pos);

    Densities[id.x] = densities;
}

uint NextRandom(inout uint state)
{
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result;
}

float RandomValue(inout uint state)
{
    return NextRandom(state) / 4294967295.0; // 2^32 - 1
}

// Calculates arbitrary normalized vector that is perpendicular to the given direction
float3 CalculateOrthonormal(float3 dir)
{
    float a = sign((sign(dir.x) + 0.5) * (sign(dir.z) + 0.5));
    float b = sign((sign(dir.y) + 0.5) * (sign(dir.z) + 0.5));
    float3 orthoVec = float3(a * dir.z, b * dir.z, -a * dir.x - b * dir.y);
    return normalize(orthoVec);
}


[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CalculatePressureForce(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    // Calculate pressure
    float density = Densities[id.x][0];
    float densityNear = Densities[id.x][1];
    float pressure = PressureFromDensity(density);
    float nearPressure = NearPressureFromDensity(densityNear);
    float3 pressureForce = 0;
    float3 velocity = Velocities[id.x];

    float3 pos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    int neighbourCount = 0;

    // Foam variables
    float weightedVelocityDifference = 0;


    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            // Skip if looking at self
            if (neighbourIndex == id.x) continue;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key) break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius) continue;

            // Calculate pressure force
            float densityNeighbour = Densities[neighbourIndex][0];
            float nearDensityNeighbour = Densities[neighbourIndex][1];
            float neighbourPressure = PressureFromDensity(densityNeighbour);
            float neighbourPressureNear = NearPressureFromDensity(nearDensityNeighbour);

            float sharedPressure = (pressure + neighbourPressure) / 2;
            float sharedNearPressure = (nearPressure + neighbourPressureNear) / 2;

            float dstToNeighbour = sqrt(sqrDstToNeighbour);
            float3 dirToNeighbour = dstToNeighbour > 0 ? offsetToNeighbour / dstToNeighbour : float3(0, 1, 0);
            neighbourCount++;

            // Update pressure force
            pressureForce += dirToNeighbour * densityDerivative(dstToNeighbour, smoothingRadius) * sharedPressure / densityNeighbour;
            pressureForce += dirToNeighbour * nearDensityDerivative(dstToNeighbour, smoothingRadius) * sharedNearPressure / nearDensityNeighbour;

            // White Particle 'Trapped Air' Calculation
            float3 relativeVelocity = velocity - Velocities[neighbourIndex];
            float relativeVelocityMagnitude = length(relativeVelocity);
            float3 relativeVelocityDir = relativeVelocity / max(0.000001, relativeVelocityMagnitude);
            // 0 if moving in opposite directions; up to 2 if moving directly toward one another
            float convergeWeight = 1 - dot(relativeVelocityDir, -dirToNeighbour);
            // 1 when distance between particles is 0, down to 0 when distance reaches the smoothing radius
            float influence = 1 - min(1, dstToNeighbour / smoothingRadius);
            // Sum up weighted velocity diff between current particle and each of its surrounding neighbours
            weightedVelocityDifference += relativeVelocityMagnitude * convergeWeight * influence;
        }
    }

    float3 acceleration = pressureForce / density;
    float3 velocityNew = velocity + acceleration * deltaTime;
    Velocities[id.x] = velocityNew;

    // Quick test -- apply some drag to airborne fluid particles
    if (neighbourCount < 8)
    {
        Velocities[id.x] -= Velocities[id.x] * deltaTime * 0.75;
    }


    // Handle spawning of white particles from the current fluid particle
    uint rngState = dot(asuint(float4(pos, simTime)), uint4(19349669, 83492837, 73856131, 4785773));
    if (id.x == 0) WhiteParticleCounters[1] = 0; // Reset survivor counter

    float trappedAirFactor = trappedAirParams[0] * Remap01(weightedVelocityDifference, trappedAirParams[1], trappedAirParams[2]);
    float kineticEnergyFactor = Remap01(dot(velocity, velocity), kineticEnergyParams[0], kineticEnergyParams[1]);
    float particleSpawnFactor = trappedAirFactor * kineticEnergyFactor * deltaTime;

    // Determine number of particles to spawn.
    int particleSpawnCount = floor(particleSpawnFactor);
    float fractionalSpawnRemainder = particleSpawnFactor - particleSpawnCount;
    if (RandomValue(rngState) < fractionalSpawnRemainder) particleSpawnCount += 1;

    //uint targ = NextRandom(rngState) % 4096;

    //InterlockedAdd(WhiteParticleCounters[targ], 1);

    if (particleSpawnCount > 0)
    {
        uint particleIndex;
        InterlockedAdd(WhiteParticleCounters[0], (uint)particleSpawnCount, particleIndex);
        particleSpawnCount = min(particleSpawnCount, MaxWhiteParticleCount - particleIndex - 1);

        float3 cylinderBase = pos;
        float3 cylinderTop = pos + velocityNew * deltaTime; // height of cylinder determined by fluid velocity
        float3 cylinderAxisA = CalculateOrthonormal(velocityNew); // arbitrary direction along base of cylinder
        float3 cylinderAxisB = normalize(cross(cylinderAxisA, velocityNew));
        float cylinderRadius = smoothingRadius;
        float clusterMin, clusterMax;
        for (int spawnIndex = 0; spawnIndex < particleSpawnCount; spawnIndex++)
        {
            float randomAngle = RandomValue(rngState) * 2 * 3.1415;
            float3 offsetDir = cos(randomAngle) * cylinderAxisA + sin(randomAngle) * cylinderAxisB;
            float3 baseOffset = sqrt(RandomValue(rngState)) * cylinderRadius * offsetDir; // random point on cylinder base
            float3 spawnPos = cylinderBase + baseOffset + (cylinderTop - cylinderBase) * RandomValue(rngState);

            float dissolveTimeMin = 5;
            float dissolveTimeMax = 15;
            float lifetime = lerp(dissolveTimeMin, dissolveTimeMax, RandomValue(rngState));

            // Spawn new particle
            WhiteParticle whiteParticle;
            whiteParticle.position = spawnPos;
            whiteParticle.velocity = velocityNew + baseOffset;
            whiteParticle.remainingLifetime = lifetime;
            whiteParticle.scale = (bubbleScale + 1) / 2;
            WhiteParticles[particleIndex + spawnIndex] = whiteParticle;
        }
    }
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CalculateViscosity(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 pos = PredictedPositions[id.x];
    int3 originCell = GetCell3D(pos, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;

    float3 viscosityForce = 0;
    float3 velocity = Velocities[id.x];

    // Neighbour search
    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;


            // Skip if looking at self
            if (neighbourIndex == id.x)
                continue;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - pos;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            // Skip if not within radius
            if (sqrDstToNeighbour > sqrRadius)
                continue;

            // Calculate viscosity
            float dst = sqrt(sqrDstToNeighbour);
            float3 neighbourVelocity = Velocities[neighbourIndex];
            viscosityForce += (neighbourVelocity - velocity) * smoothingKernelPoly6(dst, smoothingRadius);
        }
    }
    Velocities[id.x] += viscosityForce * viscosityStrength * deltaTime;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numParticles)
        return;

    float3 vel = Velocities[id.x];
    float3 pos = Positions[id.x];
    pos += vel * deltaTime;

    ResolveCollisions(pos, vel, collisionDamping);

    // Write results
    Positions[id.x] = pos;
    Velocities[id.x] = vel;
}

[numthreads(8, 8, 8)]
void UpdateDensityTexture(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= densityMapSize.x || id.y >= densityMapSize.y || id.z >= densityMapSize.z)
        return;

    // Convert threadID to a world-space position, and sample the fluid density at that point
    float3 texturePos = id / (densityMapSize - 1.0);
    float3 worldPos = (texturePos - 0.5) * boundsSize;
    DensityMap[id] = CalculateDensitiesAtPoint(worldPos)[0];
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateWhiteParticles(uint3 id : SV_DispatchThreadID)
{
    // Early exit if thread index exceeds particle count
    if (id.x >= min(MaxWhiteParticleCount, WhiteParticleCounters[0])) return;

    // Update particle
    float dt = whiteParticleDeltaTime;
    WhiteParticle particle = WhiteParticles[id.x];

    // Neighbour fluid partices
    int3 originCell = GetCell3D(particle.position, smoothingRadius);
    float sqrRadius = smoothingRadius * smoothingRadius;
    int neighbourCount = 0;
    float3 velocitySum = 0;
    float weightSum = 0;

    for (int i = 0; i < 27; i++)
    {
        uint hash = HashCell3D(originCell + offsets3D[i]);
        uint key = KeyFromHash(hash, numParticles);
        uint currIndex = SpatialOffsets[key];

        while (currIndex < numParticles)
        {
            uint neighbourIndex = currIndex;
            currIndex++;

            uint neighbourKey = SpatialKeys[neighbourIndex];
            // Exit if no longer looking at correct bin
            if (neighbourKey != key)
                break;

            float3 neighbourPos = PredictedPositions[neighbourIndex];
            float3 offsetToNeighbour = neighbourPos - particle.position;
            float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

            if (sqrDstToNeighbour < sqrRadius)
            {
                float dstToNeighbour = sqrt(sqrDstToNeighbour);
                float influenceWeight = smoothingKernelPoly6(dstToNeighbour, smoothingRadius);

                // Add up velocities of nearby fluid particles, weighted smoothly by distance.
                // Also add up the weights so that we can compute the average fluid velocity.
                velocitySum += Velocities[neighbourIndex] * influenceWeight;
                weightSum += influenceWeight;

                neighbourCount += 1;
            }
        }
    }

    //Classify
    bool isSpray = neighbourCount <= sprayClassifyMaxNeighbours;
    bool isBubble = neighbourCount >= bubbleClassifyMinNeighbours;
    bool isFoam = !(isSpray || isBubble);

    // Foam is transported by the fluid
    if (isFoam)
    {
        // We want the foam to be carried by the fluid (not just accelerated by it),
        // so the velocity is directly set to the average velocity of surrounding fluid.
        particle.velocity = velocitySum / weightSum;
        // Dissolve the foam over time
        particle.remainingLifetime -= dt;
    }
    // Bubbles are accelerated by the surrounding fluid, and moved upwards due to buoyancy
    else if (isBubble)
    {
        const float fluidAccelMul = 3; // How fast the bubble accelerates to match velocity with fluid
        float3 accelerationBuoyancy = float3(0, gravity, 0) * (1 - bubbleBuoyancy);
        float3 accelerationFluid = (velocitySum / weightSum - particle.velocity) * fluidAccelMul;
        particle.velocity += (accelerationBuoyancy + accelerationFluid) * dt;
    }
    // Spray is affected by gravity and drag
    else if (isSpray)
    {
        const float dragMultiplier = 0.04;
        float sqrSpeed = dot(particle.velocity, particle.velocity);
        float3 drag = -normalize(particle.velocity) * sqrSpeed * dragMultiplier;
        particle.velocity += (float3(0, gravity, 0) + drag) * dt;
    }

    float targetScale = isBubble ? bubbleScale : 1;
    particle.scale = lerp(particle.scale, targetScale, dt * bubbleScaleChangeSpeed);
    particle.position += particle.velocity * dt;

    const float collisionDampening = 0.1;
    ResolveCollisions(particle.position, particle.velocity, collisionDampening);
    WhiteParticles[id.x] = particle;

    // Compact the surviving particles into temporary buffer
    if (particle.remainingLifetime > 0)
    {
        uint survivorIndex;
        InterlockedAdd(WhiteParticleCounters[1], 1, survivorIndex);
        WhiteParticlesCompacted[survivorIndex] = particle;
    }
}


[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void WhiteParticlePrepareNextFrame(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= MaxWhiteParticleCount) return;

    // Copy the surviving particles back into the main particle buffer
    if (id.x < WhiteParticleCounters[1])
    {
        WhiteParticles[id.x] = WhiteParticlesCompacted[id.x];
    }

    // Set active particle count to the survivor count
    if (id.x == 0)
    {
        WhiteParticleCounters[0] = WhiteParticleCounters[1];
    }
}

------------------------------

 -- FluidDynamics2D.compute --
#pragma kernel externalForces
#pragma kernel updateSpatialHash
#pragma kernel reorder
#pragma kernel reorderCopyback
#pragma kernel calculateDensities
#pragma kernel calculatePressureForce
#pragma kernel calculateViscosity
#pragma kernel updatePositions

// Includes
#include "./FluidMath2D.hlsl"
#include "./SpatialHash.hlsl"

static const int NUM_THREADS = 64;

// Buffers
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float2> Densities; // Density, Near Density

// Spatial hashing
RWStructuredBuffer<uint> SpatialKeys;
RWStructuredBuffer<uint> SpatialOffsets;
StructuredBuffer<uint> SortedIndices;

// Settings
const uint numParticles;
const float gravity;
const float deltaTime;
const float collisionDamping;
const float smoothingRadius;
const float targetDensity;
const float pressureMultiplier;
const float nearPressureMultiplier;
const float viscosityStrength;
const float2 boundsSize;
const float2 interactionInputPoint;
const float interactionInputStrength;
const float interactionInputRadius;

const float2 obstacleSize;
const float2 obstacleCentre;

float densityKernel(float dst, float radius)
{
	return spikyKernelPow2(dst, radius);
}

float nearDensityKernel(float dst, float radius)
{
	return spikyKernelPow3(dst, radius);
}

float densityDerivative(float dst, float radius)
{
	return derivativeSpikyPow2(dst, radius);
}

float nearDensityDerivative(float dst, float radius)
{
	return derivativeSpikyPow3(dst, radius);
}

float viscosityKernel(float dst, float radius)
{
	return smoothingKernelPoly6(dst, smoothingRadius);
}

float2 calculateDensity(float2 pos)
{
	int2 originCell = getCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density = 0;
	float nearDensity = 0;

	// Neighbour search
	for (int i = 0; i < 9; i++)
	{
		uint hash = hashCell2D(originCell + OFFSETS2D[i]);
		uint key = keyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			density += densityKernel(dst, smoothingRadius);
			nearDensity += nearDensityKernel(dst, smoothingRadius);
		}
	}

	return float2(density, nearDensity);
}

float pressureFromDensity(float density)
{
	return (density - targetDensity) * pressureMultiplier;
}

float nearPressureFromDensity(float nearDensity)
{
	return nearPressureMultiplier * nearDensity;
}

float2 externalForces(float2 pos, float2 velocity)
{
	// Gravity
	float2 gravityAccel = float2(0, gravity);
	
	// Input interactions modify gravity
	if (interactionInputStrength != 0) {
		float2 inputPointOffset = interactionInputPoint - pos;
		float sqrDst = dot(inputPointOffset, inputPointOffset);
		if (sqrDst < interactionInputRadius * interactionInputRadius)
		{
			float dst = sqrt(sqrDst);
			float edgeT = (dst / interactionInputRadius);
			float centreT = 1 - edgeT;
			float2 dirToCentre = inputPointOffset / dst;

			float gravityWeight = 1 - (centreT * saturate(interactionInputStrength / 10));
			float2 accel = gravityAccel * gravityWeight + dirToCentre * centreT * interactionInputStrength;
			accel -= velocity * centreT;
			return accel;
		}
	}

	return gravityAccel;
}


void handleCollisions(uint particleIndex)
{
	float2 pos = Positions[particleIndex];
	float2 vel = Velocities[particleIndex];

	// Keep particle inside bounds
	const float2 halfSize = boundsSize * 0.5;
	float2 edgeDst = halfSize - abs(pos);

	if (edgeDst.x <= 0)
	{
		pos.x = halfSize.x * sign(pos.x);
		vel.x *= -1 * collisionDamping;
	}
	if (edgeDst.y <= 0)
	{
		pos.y = halfSize.y * sign(pos.y);
		vel.y *= -1 * collisionDamping;
	}

	// Collide particle against the test obstacle
	const float2 obstacleHalfSize = obstacleSize * 0.5;
	float2 obstacleEdgeDst = obstacleHalfSize - abs(pos - obstacleCentre);

	if (obstacleEdgeDst.x >= 0 && obstacleEdgeDst.y >= 0)
	{
		if (obstacleEdgeDst.x < obstacleEdgeDst.y) {
			pos.x = obstacleHalfSize.x * sign(pos.x - obstacleCentre.x) + obstacleCentre.x;
			vel.x *= -1 * collisionDamping;
		}
		else {
			pos.y = obstacleHalfSize.y * sign(pos.y - obstacleCentre.y) + obstacleCentre.y;
			vel.y *= -1 * collisionDamping;
		}
	}

	// Update position and velocity
	Positions[particleIndex] = pos;
	Velocities[particleIndex] = vel;
}

[numthreads(NUM_THREADS,1,1)]
void externalForces(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	// External forces (gravity and input interaction)
	Velocities[id.x] += externalForces(Positions[id.x], Velocities[id.x]) * deltaTime;

	// Predict
	const float predictionFactor = 1 / 120.0;
	PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * predictionFactor;
}

[numthreads(NUM_THREADS,1,1)]
void updateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	uint index = id.x;
	int2 cell = getCell2D(PredictedPositions[index], smoothingRadius);
	uint hash = hashCell2D(cell);
	uint key = keyFromHash(hash, numParticles);
	SpatialKeys[id.x] = key;
}

RWStructuredBuffer<float2> SortTarget_Positions;
RWStructuredBuffer<float2> SortTarget_PredictedPositions;
RWStructuredBuffer<float2> SortTarget_Velocities;

[numthreads(NUM_THREADS,1,1)]
void reorder (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	uint sortedIndex = SortedIndices[id.x];
	SortTarget_Positions[id.x] = Positions[sortedIndex];
	SortTarget_PredictedPositions[id.x] = PredictedPositions[sortedIndex];
	SortTarget_Velocities[id.x] = Velocities[sortedIndex];
}


[numthreads(NUM_THREADS,1,1)]
void reorderCopyback (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
	Positions[id.x] = SortTarget_Positions[id.x];
	PredictedPositions[id.x] = SortTarget_PredictedPositions[id.x];
	Velocities[id.x] = SortTarget_Velocities[id.x];
}


[numthreads(NUM_THREADS,1,1)]
void calculateDensities (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float2 pos = PredictedPositions[id.x];
	Densities[id.x] = calculateDensity(pos);
}

[numthreads(NUM_THREADS,1,1)]
void calculatePressureForce (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	float density = Densities[id.x][0];
	float densityNear = Densities[id.x][1];
	float pressure = pressureFromDensity(density);
	float nearPressure = nearPressureFromDensity(densityNear);
	float2 pressureForce = 0;
	
	float2 pos = PredictedPositions[id.x];
	int2 originCell = getCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	// Neighbour search
	for (int i = 0; i < 9; i ++)
	{
		uint hash = hashCell2D(originCell + OFFSETS2D[i]);
		uint key = keyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;

			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;
			
			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate pressure force
			float dst = sqrt(sqrDstToNeighbour);
			float2 dirToNeighbour = dst > 0 ? offsetToNeighbour / dst : float2(0, 1);

			float neighbourDensity = Densities[neighbourIndex][0];
			float neighbourNearDensity = Densities[neighbourIndex][1];
			float neighbourPressure = pressureFromDensity(neighbourDensity);
			float neighbourNearPressure = nearPressureFromDensity(neighbourNearDensity);

			float sharedPressure = (pressure + neighbourPressure) * 0.5;
			float sharedNearPressure = (nearPressure + neighbourNearPressure) * 0.5;

			pressureForce += dirToNeighbour * densityDerivative(dst, smoothingRadius) * sharedPressure / neighbourDensity;
			pressureForce += dirToNeighbour * nearDensityDerivative(dst, smoothingRadius) * sharedNearPressure / neighbourNearDensity;
		}
	}

	float2 acceleration = pressureForce / density;
	Velocities[id.x] += acceleration * deltaTime;//
}



[numthreads(NUM_THREADS,1,1)]
void calculateViscosity (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;
	
		
	float2 pos = PredictedPositions[id.x];
	int2 originCell = getCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;

	float2 viscosityForce = 0;
	float2 velocity = Velocities[id.x];

	for (int i = 0; i < 9; i ++)
	{
		uint hash = hashCell2D(originCell + OFFSETS2D[i]);
		uint key = keyFromHash(hash, numParticles);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticles)
		{
			uint neighbourIndex = currIndex;
			currIndex ++;

			// Skip if looking at self
			if (neighbourIndex == id.x) continue;
			
			uint neighbourKey = SpatialKeys[neighbourIndex];
			// Exit if no longer looking at correct bin
			if (neighbourKey != key) break;

			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			float dst = sqrt(sqrDstToNeighbour);
			float2 neighbourVelocity = Velocities[neighbourIndex];
			viscosityForce += (neighbourVelocity - velocity) * viscosityKernel(dst, smoothingRadius);
		}

	}
	Velocities[id.x] += viscosityForce * viscosityStrength * deltaTime;
}

[numthreads(NUM_THREADS, 1, 1)]
void updatePositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticles) return;

	Positions[id.x] += Velocities[id.x] * deltaTime;
	handleCollisions(id.x);
}
------------------------------

 -- FluidMath2D.hlsl --
const float POLY6_SCALING_FACTOR;
const float SPIKY_POW3_SCALING_FACTOR;
const float SPIKY_POW2_SCALING_FACTOR;
const float SPIKY_POW3_DERIVATIVE_SCALING_FACTOR;
const float SPIKY_POW2_DERIVATIVE_SCALING_FACTOR;

float smoothingKernelPoly6(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius * radius - dst * dst;
		return v * v * v * POLY6_SCALING_FACTOR;
	}
	return 0;
}

float spikyKernelPow3(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius - dst;
		return v * v * v * SPIKY_POW3_SCALING_FACTOR;
	}
	return 0;
}

float spikyKernelPow2(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius - dst;
		return v * v * SPIKY_POW2_SCALING_FACTOR;
	}
	return 0;
}

float derivativeSpikyPow3(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * v * SPIKY_POW3_DERIVATIVE_SCALING_FACTOR;
	}
	return 0;
}

float derivativeSpikyPow2(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * SPIKY_POW2_DERIVATIVE_SCALING_FACTOR;
	}
	return 0;
}

------------------------------

 -- FluidMath3D.hlsl --
static const float PI = 3.1415926;

const float SPIKY_POW2_SCALING_FACTOR;
const float SPIKY_POW3_SCALING_FACTOR;
const float SPIKY_POW2_DERIVATIVE_SCALING_FACTOR;
const float SPIKY_POW3_DERIVATIVE_SCALING_FACTOR;

float linearKernel(float dst, float radius)
{
    if (dst < radius)
    {
        return 1 - dst / radius;
    }
    return 0;
}

float smoothingKernelPoly6(float dst, float radius)
{
    if (dst < radius)
    {
        float scale = 315 / (64 * PI * pow(abs(radius), 9));
        float v = radius * radius - dst * dst;
        return v * v * v * scale;
    }
    return 0;
}

float spikyKernelPow3(float dst, float radius)
{
    if (dst < radius)
    {
        float v = radius - dst;
        return v * v * v * SPIKY_POW3_SCALING_FACTOR;
    }
    return 0;
}

// Integrate[(h-r)^2 r^2 Sin[θ], {r, 0, h}, {θ, 0, π}, {φ, 0, 2*π}]
float spikyKernelPow2(float dst, float radius)
{
    if (dst < radius)
    {
        float v = radius - dst;
        return v * v * SPIKY_POW2_SCALING_FACTOR;
    }
    return 0;
}

float derivativeSpikyPow3(float dst, float radius)
{
    if (dst <= radius)
    {
        float v = radius - dst;
        return -v * v * SPIKY_POW3_DERIVATIVE_SCALING_FACTOR;
    }
    return 0;
}

float derivativeSpikyPow2(float dst, float radius)
{
    if (dst <= radius)
    {
        float v = radius - dst;
        return -v * SPIKY_POW2_DERIVATIVE_SCALING_FACTOR;
    }
    return 0;
}

float densityKernel(float dst, float radius)
{
    //return smoothingKernelPoly6(dst, radius);
    return spikyKernelPow2(dst, radius);
}

float nearDensityKernel(float dst, float radius)
{
    return spikyKernelPow3(dst, radius);
}

float densityDerivative(float dst, float radius)
{
    return derivativeSpikyPow2(dst, radius);
}

float nearDensityDerivative(float dst, float radius)
{
    return derivativeSpikyPow3(dst, radius);
}


------------------------------

 -- ParticleRenderer2D.cs --
using Project.Fluid2D.Simulation;
using Project.Helpers;
using UnityEngine;

namespace Project.Fluid2D.Rendering
{
	public class ParticleRenderer2D : MonoBehaviour
	{
		public Simulation2D sim;
		public Mesh mesh;
		public Shader shader;
		public float scale;
		public Gradient colourMap;
		public int gradientResolution;
		public float velocityDisplayMax;

		Material material;
		ComputeBuffer argsBuffer;
		Bounds bounds;
		Texture2D gradientTexture;
		bool needsUpdate;

		void Awake()
		{
			if (sim == null)
			{
				sim = FindObjectOfType<Simulation2D>();
			}
			if (sim == null)
			{
				Debug.LogWarning("ParticleRenderer2D: Simulation2D not found. Disabling component.");
				enabled = false;
			}
		}

		void Start()
		{
			material = new Material(shader);
			needsUpdate = true;
		}

		void LateUpdate()
		{
			if (shader != null)
			{
				UpdateSettings();
				Graphics.DrawMeshInstancedIndirect(mesh, 0, material, bounds, argsBuffer);
			}
		}

		void UpdateSettings()
		{
			if (sim == null) return;
			material.SetBuffer("positions2D", sim.positionBuffer);
			material.SetBuffer("velocities", sim.velocityBuffer);
			material.SetBuffer("densityData", sim.densityBuffer);

			ComputeHelper.CreateArgsBuffer(ref argsBuffer, mesh, sim.positionBuffer.count);
			bounds = new Bounds(Vector3.zero, Vector3.one * 10000);

			if (needsUpdate)
			{
				needsUpdate = false;
				TextureFromGradient(ref gradientTexture, gradientResolution, colourMap);
				material.SetTexture("colourMap", gradientTexture);

				material.SetFloat("scale", scale);
				material.SetFloat("velocityMax", velocityDisplayMax);
			}
		}

		public static void TextureFromGradient(ref Texture2D texture, int width, Gradient gradient, FilterMode filterMode = FilterMode.Bilinear)
		{
			if (texture == null)
			{
				texture = new Texture2D(width, 1);
			}
			else if (texture.width != width)
			{
				texture.Reinitialize(width, 1);
			}

			if (gradient == null)
			{
				gradient = new Gradient();
				gradient.SetKeys(
					new GradientColorKey[] { new GradientColorKey(Color.black, 0), new GradientColorKey(Color.black, 1) },
					new GradientAlphaKey[] { new GradientAlphaKey(1, 0), new GradientAlphaKey(1, 1) }
				);
			}

			texture.wrapMode = TextureWrapMode.Clamp;
			texture.filterMode = filterMode;

			Color[] cols = new Color[width];
			for (int i = 0; i < cols.Length; i++)
			{
				float t = i / (cols.Length - 1f);
				cols[i] = gradient.Evaluate(t);
			}

			texture.SetPixels(cols);
			texture.Apply();
		}

		void OnValidate()
		{
			needsUpdate = true;
		}

		void OnDestroy()
		{
			ComputeHelper.Release(argsBuffer);
		}
	}
}
------------------------------

 -- ParticleSurface2D.shader --
Shader "Instanced/Particle2D" {
	Properties {
		
	}
	SubShader {

		Tags { "RenderType"="Transparent" "Queue"="Transparent" }
		Blend SrcAlpha OneMinusSrcAlpha
		ZWrite Off

		Pass {

			CGPROGRAM

			#pragma vertex vert
			#pragma fragment frag
			#pragma target 4.5

			#include "UnityCG.cginc"
			
			StructuredBuffer<float2> positions2D;
			StructuredBuffer<float2> velocities;
			StructuredBuffer<float2> densityData;
			float scale;
			float4 colA;
			Texture2D<float4> colourMap;
			SamplerState linearClampSampler;
			float velocityMax;

			struct V2F
			{
				float4 pos : SV_POSITION;
				float2 uv : TEXCOORD0;
				float3 colour : TEXCOORD1;
			};

			V2F vert (appdata_full v, uint instanceID : SV_InstanceID)
			{
				float speed = length(velocities[instanceID]);
				float speedT = saturate(speed / velocityMax);
				float colT = speedT;
				
				float3 centreWorld = float3(positions2D[instanceID], 0);
				float3 worldVertPos = centreWorld + mul(unity_ObjectToWorld, v.vertex * scale);
				float3 objectVertPos = mul(unity_WorldToObject, float4(worldVertPos.xyz, 1));

				V2F o;
				o.uv = v.texcoord;
				o.pos = UnityObjectToClipPos(objectVertPos);
				o.colour = colourMap.SampleLevel(linearClampSampler, float2(colT, 0.5), 0);

				return o;
			}


			float4 frag (V2F i) : SV_Target
			{
				float2 centreOffset = (i.uv.xy - 0.5) * 2;
				float sqrDst = dot(centreOffset, centreOffset);
				float delta = fwidth(sqrt(sqrDst));
				float alpha = 1 - smoothstep(1 - delta, 1 + delta, sqrDst);

				float3 colour = i.colour;
				return float4(colour, alpha);
			}

			ENDCG
		}
	}
}
------------------------------

 -- Simulation2D.cs --
using Project.Fluid2D.Rendering;
using Project.Helpers;
using UnityEngine;
using Unity.Mathematics;
using UnityEngine.Serialization;

namespace Project.Fluid2D.Simulation
{
	public class Simulation2D : MonoBehaviour
	{
		public event System.Action SimulationStepCompleted;

		[Header("Simulation Settings")]
		public float timeScale = 1;
		public float maxTimestepFPS = 60; // if time-step dips lower than this fps, simulation will run slower (set to 0 to disable)
		public int iterationsPerFrame;
		public float gravity;
		[Range(0, 1)] public float collisionDamping = 0.95f;
		public float smoothingRadius = 2;
		public float targetDensity;
		public float pressureMultiplier;
		public float nearPressureMultiplier;
		public float viscosityStrength;
		public Vector2 boundsSize;
		public Vector2 obstacleSize;
		public Vector2 obstacleCentre;

		[Header("Interaction Settings")]
		public float interactionRadius;

		public float interactionStrength;

		[Header("References")]
		public ComputeShader compute;

		public SpawnParticles2D spawner2D;

		// Buffers
		public ComputeBuffer positionBuffer { get; private set; }
		public ComputeBuffer velocityBuffer { get; private set; }
		public ComputeBuffer densityBuffer { get; private set; }

		ComputeBuffer sortTarget_Position;
		ComputeBuffer sortTarget_PredicitedPosition;
		ComputeBuffer sortTarget_Velocity;

		ComputeBuffer predictedPositionBuffer;
        SpatialIndex spatialHash;

		// Kernel IDs
		const int externalForcesKernel = 0;
		const int spatialHashKernel = 1;
		const int reorderKernel = 2;
		const int copybackKernel = 3;
		const int densityKernel = 4;
		const int pressureKernel = 5;
		const int viscosityKernel = 6;
		const int updatePositionKernel = 7;

		// State
		bool isPaused;
		SpawnParticles2D.ParticleSpawnData spawnData;
		bool pauseNextFrame;

		public int numParticles { get; private set; }


		void Start()
		{
			Debug.Log("Controls: Space = Play/Pause, R = Reset, LMB = Attract, RMB = Repel");

			if (spawner2D == null)
			{
				spawner2D = FindObjectOfType<SpawnParticles2D>();
			}
			if (spawner2D == null)
			{
				Debug.LogError("SpawnParticles2D not found. Disabling Simulation2D.");
				enabled = false; return;
			}
			if (compute == null)
			{
				compute = Resources.Load<ComputeShader>("FluidDynamics2D");
				if (compute == null)
				{
					Debug.LogError("ComputeShader FluidDynamics2D not found.");
					enabled = false; return;
				}
			}
			float deltaTime = 1 / 60f;
			Time.fixedDeltaTime = deltaTime;

			spawnData = spawner2D.GetSpawnData();
			numParticles = spawnData.positions.Length;
			spatialHash = new SpatialIndex(numParticles);

			// Create buffers
			positionBuffer = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);
			predictedPositionBuffer = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);
			velocityBuffer = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);
			densityBuffer = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);

			sortTarget_Position = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);
			sortTarget_PredicitedPosition = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);
			sortTarget_Velocity = ComputeHelper.CreateStructuredBuffer<float2>(numParticles);

			// Set buffer data
			SetInitialBufferData(spawnData);

			// Init compute
			ComputeHelper.SetBuffer(compute, positionBuffer, "Positions", externalForcesKernel, updatePositionKernel, reorderKernel, copybackKernel);
			ComputeHelper.SetBuffer(compute, predictedPositionBuffer, "PredictedPositions", externalForcesKernel, spatialHashKernel, densityKernel, pressureKernel, viscosityKernel, reorderKernel, copybackKernel);
			ComputeHelper.SetBuffer(compute, velocityBuffer, "Velocities", externalForcesKernel, pressureKernel, viscosityKernel, updatePositionKernel, reorderKernel, copybackKernel);
			ComputeHelper.SetBuffer(compute, densityBuffer, "Densities", densityKernel, pressureKernel, viscosityKernel);

			ComputeHelper.SetBuffer(compute, spatialHash.spatialIndices, "SortedIndices", spatialHashKernel, reorderKernel);
			ComputeHelper.SetBuffer(compute, spatialHash.spatialOffsets, "SpatialOffsets", spatialHashKernel, densityKernel, pressureKernel, viscosityKernel);
			ComputeHelper.SetBuffer(compute, spatialHash.spatialKeys, "SpatialKeys", spatialHashKernel, densityKernel, pressureKernel, viscosityKernel);

			ComputeHelper.SetBuffer(compute, sortTarget_Position, "SortTarget_Positions", reorderKernel, copybackKernel);
			ComputeHelper.SetBuffer(compute, sortTarget_PredicitedPosition, "SortTarget_PredictedPositions", reorderKernel, copybackKernel);
			ComputeHelper.SetBuffer(compute, sortTarget_Velocity, "SortTarget_Velocities", reorderKernel, copybackKernel);

			compute.SetInt("numParticles", numParticles);
		}


		void Update()
		{
			if (!isPaused)
			{
				float maxDeltaTime = maxTimestepFPS > 0 ? 1 / maxTimestepFPS : float.PositiveInfinity; // If framerate dips too low, run the simulation slower than real-time
				float dt = Mathf.Min(Time.deltaTime * timeScale, maxDeltaTime);
				RunSimulationFrame(dt);
			}

			if (pauseNextFrame)
			{
				isPaused = true;
				pauseNextFrame = false;
			}

			HandleInput();
		}

		void RunSimulationFrame(float frameTime)
		{
			float timeStep = frameTime / iterationsPerFrame;

			UpdateSettings(timeStep);

			for (int i = 0; i < iterationsPerFrame; i++)
			{
				RunSimulationStep();
				SimulationStepCompleted?.Invoke();
			}
		}

		void RunSimulationStep()
		{
			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: externalForcesKernel);

			RunSpatial();

			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: densityKernel);
			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: pressureKernel);
			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: viscosityKernel);
			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: updatePositionKernel);
		}

		void RunSpatial()
		{
			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: spatialHashKernel);
			spatialHash.Run();

			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: reorderKernel);
			ComputeHelper.Dispatch(compute, numParticles, kernelIndex: copybackKernel);
		}

		void UpdateSettings(float deltaTime)
		{
			compute.SetFloat("deltaTime", deltaTime);
			compute.SetFloat("gravity", gravity);
			compute.SetFloat("collisionDamping", collisionDamping);
			compute.SetFloat("smoothingRadius", smoothingRadius);
			compute.SetFloat("targetDensity", targetDensity);
			compute.SetFloat("pressureMultiplier", pressureMultiplier);
			compute.SetFloat("nearPressureMultiplier", nearPressureMultiplier);
			compute.SetFloat("viscosityStrength", viscosityStrength);
			compute.SetVector("boundsSize", boundsSize);
			compute.SetVector("obstacleSize", obstacleSize);
			compute.SetVector("obstacleCentre", obstacleCentre);

			compute.SetFloat("POLY6_SCALING_FACTOR", 4 / (Mathf.PI * Mathf.Pow(smoothingRadius, 8)));
			compute.SetFloat("SPIKY_POW3_SCALING_FACTOR", 10 / (Mathf.PI * Mathf.Pow(smoothingRadius, 5)));
			compute.SetFloat("SPIKY_POW2_SCALING_FACTOR", 6 / (Mathf.PI * Mathf.Pow(smoothingRadius, 4)));
			compute.SetFloat("SPIKY_POW3_DERIVATIVE_SCALING_FACTOR", 30 / (Mathf.Pow(smoothingRadius, 5) * Mathf.PI));
			compute.SetFloat("SPIKY_POW2_DERIVATIVE_SCALING_FACTOR", 12 / (Mathf.Pow(smoothingRadius, 4) * Mathf.PI));

			// Mouse interaction settings:
			Vector2 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
			bool isPullInteraction = Input.GetMouseButton(0);
			bool isPushInteraction = Input.GetMouseButton(1);
			float currInteractStrength = 0;
			if (isPushInteraction || isPullInteraction)
			{
				currInteractStrength = isPushInteraction ? -interactionStrength : interactionStrength;
			}

			compute.SetVector("interactionInputPoint", mousePos);
			compute.SetFloat("interactionInputStrength", currInteractStrength);
			compute.SetFloat("interactionInputRadius", interactionRadius);
		}

		void SetInitialBufferData(SpawnParticles2D.ParticleSpawnData spawnData)
		{
			float2[] allPoints = new float2[spawnData.positions.Length]; //
			System.Array.Copy(spawnData.positions, allPoints, spawnData.positions.Length);

			positionBuffer.SetData(allPoints);
			predictedPositionBuffer.SetData(allPoints);
			velocityBuffer.SetData(spawnData.velocities);
		}

		void HandleInput()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				isPaused = !isPaused;
			}

			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				isPaused = false;
				pauseNextFrame = true;
			}

			if (Input.GetKeyDown(KeyCode.R))
			{
				isPaused = true;
				// Reset positions, the run single frame to get density etc (for debug purposes) and then reset positions again
				SetInitialBufferData(spawnData);
				RunSimulationStep();
				SetInitialBufferData(spawnData);
			}
		}


		void OnDestroy()
		{
			ComputeHelper.Release(positionBuffer, predictedPositionBuffer, velocityBuffer, densityBuffer, sortTarget_Position, sortTarget_Velocity, sortTarget_PredicitedPosition);
			spatialHash.Release();
		}


		void OnDrawGizmos()
		{
			Gizmos.color = new Color(0, 1, 0, 0.4f);
			Gizmos.DrawWireCube(Vector2.zero, boundsSize);
			Gizmos.DrawWireCube(obstacleCentre, obstacleSize);

			if (Application.isPlaying)
			{
				Vector2 mousePos = Camera.main.ScreenToWorldPoint(Input.mousePosition);
				bool isPullInteraction = Input.GetMouseButton(0);
				bool isPushInteraction = Input.GetMouseButton(1);
				bool isInteracting = isPullInteraction || isPushInteraction;
				if (isInteracting)
				{
					Gizmos.color = isPullInteraction ? Color.green : Color.red;
					Gizmos.DrawWireSphere(mousePos, interactionRadius);
				}
			}
		}
	}
}
------------------------------

 -- Simulation3D.cs --
using System;
using UnityEngine;
using Project.GPUSorting;
using Unity.Mathematics;
using System.Collections.Generic;
using Project.Helpers;
using static Project.Helpers.ComputeHelper;

namespace Project.Fluid.Simulation
{
	public class Simulation3D : MonoBehaviour
	{
		public event Action<Simulation3D> SimulationInitCompleted;

		[Header("Time Step")] public float normalTimeScale = 1;
		public float slowTimeScale = 0.1f;
		public float maxTimestepFPS = 60;
		public int iterationsPerFrame = 3;

		[Header("Simulation Settings")] public float gravity = -10;
		public float smoothingRadius = 0.2f;
		public float targetDensity = 630;
		public float pressureMultiplier = 288;
		public float nearPressureMultiplier = 2.15f;
		public float viscosityStrength = 0;
		[Range(0, 1)] public float collisionDamping = 0.95f;

		[Header("Foam Settings")] public bool foamActive;
		public int maxFoamParticleCount = 1000;
		public float trappedAirSpawnRate = 70;
		public float spawnRateFadeInTime = 0.5f;
		public float spawnRateFadeStartTime = 0;
		public Vector2 trappedAirVelocityMinMax = new(5, 25);
		public Vector2 foamKineticEnergyMinMax = new(15, 80);
		public float bubbleBuoyancy = 1.5f;
		public int sprayClassifyMaxNeighbours = 5;
		public int bubbleClassifyMinNeighbours = 15;
		public float bubbleScale = 0.5f;
		public float bubbleChangeScaleSpeed = 7;

		[Header("Volumetric Render Settings")] public bool renderToTex3D;
		public int densityTextureRes;

		[Header("References")] public ComputeShader compute;
		public SpawnParticles3D spawner;

		[HideInInspector] public RenderTexture DensityMap;
		public Vector3 Scale => transform.localScale;

		// Buffers
		public ComputeBuffer foamBuffer { get; private set; }
		public ComputeBuffer foamSortTargetBuffer { get; private set; }
		public ComputeBuffer foamCountBuffer { get; private set; }
		public ComputeBuffer positionBuffer { get; private set; }
		public ComputeBuffer velocityBuffer { get; private set; }
		public ComputeBuffer densityBuffer { get; private set; }
		public ComputeBuffer predictedPositionsBuffer;
		public ComputeBuffer debugBuffer { get; private set; }

		private ComputeBuffer sortTarget_positionBuffer;
		private ComputeBuffer sortTarget_velocityBuffer;
		private ComputeBuffer sortTarget_predictedPositionsBuffer;

		// Kernel IDs
		private const int externalForcesKernel = 0;
		private const int spatialHashKernel = 1;
		private const int reorderKernel = 2;
		private const int reorderCopybackKernel = 3;
		private const int densityKernel = 4;
		private const int pressureKernel = 5;
		private const int viscosityKernel = 6;
		private const int updatePositionsKernel = 7;
		private const int renderKernel = 8;
		private const int foamUpdateKernel = 9;
		private const int foamReorderCopyBackKernel = 10;

        SpatialIndex spatialHash;

		// State
		private bool _isPaused;
		private bool _pauseNextFrame;
		private float _smoothRadiusOld;
		private float _simTimer;
		private bool _inSlowMode;
		private SpawnParticles3D.SpawnData _spawnData;
		private Dictionary<ComputeBuffer, string> _bufferNameLookup;

		private void Start()
		{
			Debug.Log("Controls: Space = Play/Pause, Q = SlowMode, R = Reset");
			_isPaused = false;

			if (spawner == null)
			{
				spawner = FindObjectOfType<SpawnParticles3D>();
				if (spawner == null)
				{
					Debug.LogError("SpawnParticles3D component not found. Simulation3D disabled.");
					enabled = false;
					return;
				}
			}

			Initialize();
		}

		private void Initialize()
		{
			if (compute == null)
			{
				compute = Resources.Load<ComputeShader>("FluidDynamics"); // fallback
				if (compute == null)
				{
					Debug.LogError("ComputeShader for Simulation3D not assigned and not found. Disabling.");
					enabled = false;
					return;
				}
			}

			_spawnData = spawner.GetSpawnData();
			int numParticles = _spawnData.points.Length;

			spatialHash = new SpatialIndex(numParticles);
			
			// Create buffers
			positionBuffer = CreateStructuredBuffer<float3>(numParticles);
			predictedPositionsBuffer = CreateStructuredBuffer<float3>(numParticles);
			velocityBuffer = CreateStructuredBuffer<float3>(numParticles);
			densityBuffer = CreateStructuredBuffer<float2>(numParticles);
			foamBuffer = CreateStructuredBuffer<FoamParticle>(maxFoamParticleCount);
			foamSortTargetBuffer = CreateStructuredBuffer<FoamParticle>(maxFoamParticleCount);
			foamCountBuffer = CreateStructuredBuffer<uint>(4096);
			debugBuffer = CreateStructuredBuffer<float3>(numParticles);

			sortTarget_positionBuffer = CreateStructuredBuffer<float3>(numParticles);
			sortTarget_predictedPositionsBuffer = CreateStructuredBuffer<float3>(numParticles);
			sortTarget_velocityBuffer = CreateStructuredBuffer<float3>(numParticles);

			_bufferNameLookup = new Dictionary<ComputeBuffer, string>
			{
				{ positionBuffer, "Positions" },
				{ predictedPositionsBuffer, "PredictedPositions" },
				{ velocityBuffer, "Velocities" },
				{ densityBuffer, "Densities" },
				{ spatialHash.spatialKeys, "SpatialKeys" },
				{ spatialHash.spatialOffsets, "SpatialOffsets" },
				{ spatialHash.spatialIndices, "SortedIndices" },
				{ sortTarget_positionBuffer, "SortTarget_Positions" },
				{ sortTarget_predictedPositionsBuffer, "SortTarget_PredictedPositions" },
				{ sortTarget_velocityBuffer, "SortTarget_Velocities" },
				{ foamCountBuffer, "WhiteParticleCounters" },
				{ foamBuffer, "WhiteParticles" },
				{ foamSortTargetBuffer, "WhiteParticlesCompacted" },
				{ debugBuffer, "Debug" }
			};

			// Set buffer data
			SetInitialBufferData(_spawnData);

			// External forces kernel
			SetBuffers(compute, externalForcesKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				positionBuffer,
				predictedPositionsBuffer,
				velocityBuffer
			});

			// Spatial hash kernel
			SetBuffers(compute, spatialHashKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				spatialHash.spatialKeys,
				spatialHash.spatialOffsets,
				predictedPositionsBuffer,
				spatialHash.spatialIndices
			});

			// Reorder kernel
			SetBuffers(compute, reorderKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				positionBuffer,
				sortTarget_positionBuffer,
				predictedPositionsBuffer,
				sortTarget_predictedPositionsBuffer,
				velocityBuffer,
				sortTarget_velocityBuffer,
				spatialHash.spatialIndices
			});

			// Reorder copyback kernel
			SetBuffers(compute, reorderCopybackKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				positionBuffer,
				sortTarget_positionBuffer,
				predictedPositionsBuffer,
				sortTarget_predictedPositionsBuffer,
				velocityBuffer,
				sortTarget_velocityBuffer,
				spatialHash.spatialIndices
			});

			// Density kernel
			SetBuffers(compute, densityKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				predictedPositionsBuffer,
				densityBuffer,
				spatialHash.spatialKeys,
				spatialHash.spatialOffsets
			});

			// Pressure kernel
			SetBuffers(compute, pressureKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				predictedPositionsBuffer,
				densityBuffer,
				velocityBuffer,
				spatialHash.spatialKeys,
				spatialHash.spatialOffsets,
				foamBuffer,
				foamCountBuffer,
				debugBuffer
			});

			// Viscosity kernel
			SetBuffers(compute, viscosityKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				predictedPositionsBuffer,
				densityBuffer,
				velocityBuffer,
				spatialHash.spatialKeys,
				spatialHash.spatialOffsets
			});

			// Update positions kernel
			SetBuffers(compute, updatePositionsKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				positionBuffer,
				velocityBuffer
			});

			// Render to 3d tex kernel
			SetBuffers(compute, renderKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				predictedPositionsBuffer,
				densityBuffer,
				spatialHash.spatialKeys,
				spatialHash.spatialOffsets,
			});

			// Foam update kernel
			SetBuffers(compute, foamUpdateKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				foamBuffer,
				foamCountBuffer,
				predictedPositionsBuffer,
				densityBuffer,
				velocityBuffer,
				spatialHash.spatialKeys,
				spatialHash.spatialOffsets,
				foamSortTargetBuffer,
				//debugBuffer
			});


			// Foam reorder copyback kernel
			SetBuffers(compute, foamReorderCopyBackKernel, _bufferNameLookup, new ComputeBuffer[]
			{
				foamBuffer,
				foamSortTargetBuffer,
				foamCountBuffer,
			});

			compute.SetInt("numParticles", positionBuffer.count);
			compute.SetInt("MaxWhiteParticleCount", maxFoamParticleCount);

			UpdateSmoothingConstants();

			// Run single frame of sim with deltaTime = 0 to initialize density texture
			// (so that display can work even if paused at start)
			if (renderToTex3D)
			{
				RunSimulationFrame(0);
			}

			SimulationInitCompleted?.Invoke(this);
		}

		private void Update()
		{
			// Run simulation
			if (!_isPaused)
			{
				float maxDeltaTime = maxTimestepFPS > 0 ? 1 / maxTimestepFPS : float.PositiveInfinity; // If framerate dips too low, run the simulation slower than real-time
				float dt = Mathf.Min(Time.deltaTime * ActiveTimeScale, maxDeltaTime);
				RunSimulationFrame(dt);
			}

			if (_pauseNextFrame)
			{
				_isPaused = true;
				_pauseNextFrame = false;
			}

			HandleInput();
		}

		private void RunSimulationFrame(float frameDeltaTime)
		{
			float subStepDeltaTime = frameDeltaTime / iterationsPerFrame;
			UpdateSettings(subStepDeltaTime, frameDeltaTime);

			// Simulation sub-steps
			for (int i = 0; i < iterationsPerFrame; i++)
			{
				_simTimer += subStepDeltaTime;
				RunSimulationStep();
			}

			// Foam and spray particles
			if (foamActive)
			{
				Dispatch(compute, maxFoamParticleCount, kernelIndex: foamUpdateKernel);
				Dispatch(compute, maxFoamParticleCount, kernelIndex: foamReorderCopyBackKernel);
			}

			// 3D density map
			if (renderToTex3D)
			{
				UpdateDensityMap();
			}
		}

		private void UpdateDensityMap()
		{
			float maxAxis = Mathf.Max(transform.localScale.x, transform.localScale.y, transform.localScale.z);
			int w = Mathf.RoundToInt(transform.localScale.x / maxAxis * densityTextureRes);
			int h = Mathf.RoundToInt(transform.localScale.y / maxAxis * densityTextureRes);
			int d = Mathf.RoundToInt(transform.localScale.z / maxAxis * densityTextureRes);
			CreateRenderTexture3D(ref DensityMap, w, h, d, UnityEngine.Experimental.Rendering.GraphicsFormat.R16_SFloat, TextureWrapMode.Clamp);
			//Debug.Log(w + " " + h + "  " + d);
			compute.SetTexture(renderKernel, "DensityMap", DensityMap);
			compute.SetInts("densityMapSize", DensityMap.width, DensityMap.height, DensityMap.volumeDepth);
			Dispatch(compute, DensityMap.width, DensityMap.height, DensityMap.volumeDepth, renderKernel);
		}

		private void RunSimulationStep()
		{
			Dispatch(compute, positionBuffer.count, kernelIndex: externalForcesKernel);

			Dispatch(compute, positionBuffer.count, kernelIndex: spatialHashKernel);
			spatialHash.Run();
			
			Dispatch(compute, positionBuffer.count, kernelIndex: reorderKernel);
			Dispatch(compute, positionBuffer.count, kernelIndex: reorderCopybackKernel);

			Dispatch(compute, positionBuffer.count, kernelIndex: densityKernel);
			Dispatch(compute, positionBuffer.count, kernelIndex: pressureKernel);
			if (viscosityStrength != 0) Dispatch(compute, positionBuffer.count, kernelIndex: viscosityKernel);
			Dispatch(compute, positionBuffer.count, kernelIndex: updatePositionsKernel);
		}

		private void UpdateSmoothingConstants()
		{
			float r = smoothingRadius;
			float spikyPow2 = 15 / (2 * Mathf.PI * Mathf.Pow(r, 5));
			float spikyPow3 = 15 / (Mathf.PI * Mathf.Pow(r, 6));
			float spikyPow2Grad = 15 / (Mathf.PI * Mathf.Pow(r, 5));
			float spikyPow3Grad = 45 / (Mathf.PI * Mathf.Pow(r, 6));

			compute.SetFloat("SPIKY_POW2_SCALING_FACTOR", spikyPow2);
			compute.SetFloat("SPIKY_POW3_SCALING_FACTOR", spikyPow3);
			compute.SetFloat("SPIKY_POW2_DERIVATIVE_SCALING_FACTOR", spikyPow2Grad);
			compute.SetFloat("SPIKY_POW3_DERIVATIVE_SCALING_FACTOR", spikyPow3Grad);
		}

		private void UpdateSettings(float stepDeltaTime, float frameDeltaTime)
		{
			if (smoothingRadius != _smoothRadiusOld)
			{
				_smoothRadiusOld = smoothingRadius;
				UpdateSmoothingConstants();
			}

			Vector3 simBoundsSize = transform.localScale;
			Vector3 simBoundsCentre = transform.position;

			compute.SetFloat("deltaTime", stepDeltaTime);
			compute.SetFloat("whiteParticleDeltaTime", frameDeltaTime);
			compute.SetFloat("simTime", _simTimer);
			compute.SetFloat("gravity", gravity);
			compute.SetFloat("collisionDamping", collisionDamping);
			compute.SetFloat("smoothingRadius", smoothingRadius);
			compute.SetFloat("targetDensity", targetDensity);
			compute.SetFloat("pressureMultiplier", pressureMultiplier);
			compute.SetFloat("nearPressureMultiplier", nearPressureMultiplier);
			compute.SetFloat("viscosityStrength", viscosityStrength);
			compute.SetVector("boundsSize", simBoundsSize);
			compute.SetVector("centre", simBoundsCentre);

			compute.SetMatrix("localToWorld", transform.localToWorldMatrix);
			compute.SetMatrix("worldToLocal", transform.worldToLocalMatrix);

			// Foam settings
			float fadeInT = (spawnRateFadeInTime <= 0) ? 1 : Mathf.Clamp01((_simTimer - spawnRateFadeStartTime) / spawnRateFadeInTime);
			compute.SetVector("trappedAirParams", new Vector3(trappedAirSpawnRate * fadeInT * fadeInT, trappedAirVelocityMinMax.x, trappedAirVelocityMinMax.y));
			compute.SetVector("kineticEnergyParams", foamKineticEnergyMinMax);
			compute.SetFloat("bubbleBuoyancy", bubbleBuoyancy);
			compute.SetInt("sprayClassifyMaxNeighbours", sprayClassifyMaxNeighbours);
			compute.SetInt("bubbleClassifyMinNeighbours", bubbleClassifyMinNeighbours);
			compute.SetFloat("bubbleScaleChangeSpeed", bubbleChangeScaleSpeed);
			compute.SetFloat("bubbleScale", bubbleScale);
		}

		private void SetInitialBufferData(SpawnParticles3D.SpawnData spawnData)
		{
			positionBuffer.SetData(spawnData.points);
			predictedPositionsBuffer.SetData(spawnData.points);
			velocityBuffer.SetData(spawnData.velocities);

			foamBuffer.SetData(new FoamParticle[foamBuffer.count]);

			debugBuffer.SetData(new float3[debugBuffer.count]);
			foamCountBuffer.SetData(new uint[foamCountBuffer.count]);
			_simTimer = 0;
		}

		private void HandleInput()
		{
			if (Input.GetKeyDown(KeyCode.Space))
			{
				_isPaused = !_isPaused;
			}

			if (Input.GetKeyDown(KeyCode.RightArrow))
			{
				_isPaused = false;
				_pauseNextFrame = true;
			}

			if (Input.GetKeyDown(KeyCode.R))
			{
				_pauseNextFrame = true;
				SetInitialBufferData(_spawnData);
				// Run single frame of sim with deltaTime = 0 to initialize density texture
				// (so that display can work even if paused at start)
				if (renderToTex3D)
				{
					RunSimulationFrame(0);
				}
			}

			if (Input.GetKeyDown(KeyCode.Q))
			{
				_inSlowMode = !_inSlowMode;
			}
		}

		private float ActiveTimeScale => _inSlowMode ? slowTimeScale : normalTimeScale;

		private void OnDestroy()
		{
			foreach (var kvp in _bufferNameLookup)
			{
				Release(kvp.Key);
			}

			if (spatialHash != null)
			{
				spatialHash.Release();
			}
		}


		public struct FoamParticle
		{
			public float3 position;
			public float3 velocity;
			public float lifetime;
			public float scale;
		}

		private void OnDrawGizmos()
		{
			// Draw Bounds
			var m = Gizmos.matrix;
			Gizmos.matrix = transform.localToWorldMatrix;
			Gizmos.color = new Color(0, 1, 0, 0.5f);
			Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
			Gizmos.matrix = m;
		}
	}
}
------------------------------

 -- SpatialHash.hlsl --
static const int2 OFFSETS2D[9] =
{
	int2(-1, 1),
	int2(0, 1),
	int2(1, 1),
	int2(-1, 0),
	int2(0, 0),
	int2(1, 0),
	int2(-1, -1),
	int2(0, -1),
	int2(1, -1),
};

// Constants used for hashing
static const uint HASH_K1 = 15823;
static const uint HASH_K2 = 9737333;

// Convert floating point position into an integer cell coordinate
int2 getCell2D(float2 position, float radius)
{
	return (int2)floor(position / radius);
}

// Hash cell coordinate to a single unsigned integer
uint hashCell2D(int2 cell)
{
	cell = (uint2)cell;
	uint a = cell.x * HASH_K1;
	uint b = cell.y * HASH_K2;
	return (a + b);
}

uint keyFromHash(uint hash, uint tableSize)
{
	return hash % tableSize;
}

------------------------------

 -- SpatialHash3D.hlsl --
static const int3 offsets3D[27] =
{
	int3(-1, -1, -1),
	int3(0, -1, -1),
	int3(1, -1, -1),

	int3(-1, 0, -1),
	int3(0, 0, -1),
	int3(1, 0, -1),

	int3(-1, 1, -1),
	int3(0, 1, -1),
	int3(1, 1, -1),

	int3(-1, -1, 0),
	int3(0, -1, 0),
	int3(1, -1, 0),

	int3(-1, 0, 0),
	int3(0, 0, 0),
	int3(1, 0, 0),

	int3(-1, 1, 0),
	int3(0, 1, 0),
	int3(1, 1, 0),

	int3(-1, -1, 1),
	int3(0, -1, 1),
	int3(1, -1, 1),

	int3(-1, 0, 1),
	int3(0, 0, 1),
	int3(1, 0, 1),

	int3(-1, 1, 1),
	int3(0, 1, 1),
	int3(1, 1, 1)
};

// Constants used for hashing
static const uint hashK1 = 15823;
static const uint hashK2 = 9737333;
static const uint hashK3 = 440817757;

// Convert floating point position into an integer cell coordinate
int3 GetCell3D(float3 position, float radius)
{
	return (int3)floor(position / radius);
}

// Hash cell coordinate to a single unsigned integer
// TODO: investigate better hashing functions
uint HashCell3D(int3 cell)
{
	const uint blockSize = 50;
	uint3 ucell = (uint3) (cell + blockSize / 2);

	uint3 localCell = ucell % blockSize;
	uint3 blockID = ucell / blockSize;
	uint blockHash = blockID.x * hashK1 + blockID.y * hashK2 + blockID.z * hashK3;
	return localCell.x + blockSize * (localCell.y + blockSize * localCell.z) + blockHash;

}

uint KeyFromHash(uint hash, uint tableSize)
{
	return hash % tableSize;
}

------------------------------

 -- SpawnParticles2D.cs --
using System.Collections.Generic;
using UnityEngine;
using Unity.Mathematics;

public class SpawnParticles2D : MonoBehaviour
{
	public float spawnDensity;

	public Vector2 initialVelocity;
	public float jitterStr;
	public SpawnRegion[] spawnRegions;
	public bool showSpawnBoundsGizmos;

	[Header("Debug Info")]
	public int spawnParticleCount;

	public ParticleSpawnData GetSpawnData()
	{
		var rng = new Unity.Mathematics.Random(42);

		List<float2> allPoints = new();
		List<float2> allVelocities = new();
		List<int> allIndices = new();

		for (int regionIndex = 0; regionIndex < spawnRegions.Length; regionIndex++)
		{
			SpawnRegion region = spawnRegions[regionIndex];
			float2[] points = SpawnInRegion(region);

			for (int i = 0; i < points.Length; i++)
			{
				float angle = (float)rng.NextDouble() * 3.14f * 2;
				float2 dir = new float2(Mathf.Cos(angle), Mathf.Sin(angle));
				float2 jitter = dir * jitterStr * ((float)rng.NextDouble() - 0.5f);
				allPoints.Add(points[i] + jitter);
				allVelocities.Add(initialVelocity);
				allIndices.Add(regionIndex);
			}
		}

		ParticleSpawnData data = new()
		{
			positions = allPoints.ToArray(),
			velocities = allVelocities.ToArray(),
			spawnIndices = allIndices.ToArray(),
		};

		return data;
	}

	float2[] SpawnInRegion(SpawnRegion region)
	{
		Vector2 centre = region.position;
		Vector2 size = region.size;
		int i = 0;
		Vector2Int numPerAxis = CalculateSpawnCountPerAxisBox2D(region.size, spawnDensity);
		float2[] points = new float2[numPerAxis.x * numPerAxis.y];

		for (int y = 0; y < numPerAxis.y; y++)
		{
			for (int x = 0; x < numPerAxis.x; x++)
			{
				float tx = x / (numPerAxis.x - 1f);
				float ty = y / (numPerAxis.y - 1f);

				float px = (tx - 0.5f) * size.x + centre.x;
				float py = (ty - 0.5f) * size.y + centre.y;
				points[i] = new float2(px, py);
				i++;
			}
		}

		return points;
	}

	static Vector2Int CalculateSpawnCountPerAxisBox2D(Vector2 size, float spawnDensity)
	{
		float area = size.x * size.y;
		int targetTotal = Mathf.CeilToInt(area * spawnDensity);

		float lenSum = size.x + size.y;
		Vector2 t = size / lenSum;
		float m = Mathf.Sqrt(targetTotal / (t.x * t.y));
		int nx = Mathf.CeilToInt(t.x * m);
		int ny = Mathf.CeilToInt(t.y * m);

		return new Vector2Int(nx, ny);
	}

	public struct ParticleSpawnData
	{
		public float2[] positions;
		public float2[] velocities;
		public int[] spawnIndices;

		public ParticleSpawnData(int num)
		{
			positions = new float2[num];
			velocities = new float2[num];
			spawnIndices = new int[num];
		}
	}

	[System.Serializable]
	public struct SpawnRegion
	{
		public Vector2 position;
		public Vector2 size;
		public Color debugCol;
	}

	void OnValidate()
	{
		spawnParticleCount = 0;
		foreach (SpawnRegion region in spawnRegions)
		{
			Vector2Int spawnCountPerAxis = CalculateSpawnCountPerAxisBox2D(region.size, spawnDensity);
			spawnParticleCount += spawnCountPerAxis.x * spawnCountPerAxis.y;
		}
	}

	void OnDrawGizmos()
	{
		if (showSpawnBoundsGizmos && !Application.isPlaying)
		{
			foreach (SpawnRegion region in spawnRegions)
			{
				Gizmos.color = region.debugCol;
				Gizmos.DrawWireCube(region.position, region.size);
			}
		}
	}
}
------------------------------

 -- SpawnParticles3D.cs --
using System;
using System.Collections.Generic;
using Unity.Mathematics;
using UnityEngine;

namespace Project.Fluid.Simulation
{

	public class SpawnParticles3D : MonoBehaviour
	{
		public int particleSpawnDensity = 600;
		public float3 initialVel;
		public float jitterStrength;
		public bool showSpawnBounds;
		public SpawnRegion[] spawnRegions;

		[Header("Randomization Settings")]
		public bool randomizeRegions;
		public Vector3 boundsMin;
		public Vector3 boundsMax;
		public Vector2 sizeMinMax;

		[Header("Debug Info")] public int debug_num_particles;
		public float debug_spawn_volume;


		public SpawnData GetSpawnData()
		{
			if (randomizeRegions)
			{
				RandomizeRegions();
			}
			List<float3> allPoints = new();
			List<float3> allVelocities = new();

			foreach (SpawnRegion region in spawnRegions)
			{
				int particlesPerAxis = region.CalculateParticleCountPerAxis(particleSpawnDensity);
				(float3[] points, float3[] velocities) = SpawnCube(particlesPerAxis, region.centre, Vector3.one * region.size);
				allPoints.AddRange(points);
				allVelocities.AddRange(velocities);
			}

			return new SpawnData() { points = allPoints.ToArray(), velocities = allVelocities.ToArray() };
		}

		void RandomizeRegions()
		{
			if (spawnRegions == null || spawnRegions.Length == 0) return;

			for (int i = 0; i < spawnRegions.Length; i++)
			{
				SpawnRegion region = spawnRegions[i];
				region.centre = new Vector3(
					UnityEngine.Random.Range(boundsMin.x, boundsMax.x),
					UnityEngine.Random.Range(boundsMin.y, boundsMax.y),
					UnityEngine.Random.Range(boundsMin.z, boundsMax.z));

				region.size = UnityEngine.Random.Range(sizeMinMax.x, sizeMinMax.y);
				spawnRegions[i] = region;
			}
		}

		private (float3[] p, float3[] v) SpawnCube(int numPerAxis, Vector3 centre, Vector3 size)
		{
			int totalPoints = numPerAxis * numPerAxis * numPerAxis;
			float3[] points = new float3[totalPoints];
			float3[] velocities = new float3[totalPoints];

			int index = 0;

			for (int x = 0; x < numPerAxis; x++)
			{
				for (int y = 0; y < numPerAxis; y++)
				{
					for (int z = 0; z < numPerAxis; z++)
					{
						float3 jitter = (float3)(UnityEngine.Random.insideUnitSphere * jitterStrength);
						points[index] = CalculatePointPosition(x, y, z, numPerAxis, centre, size) + jitter;
						velocities[index] = initialVel;
						index++;
					}
				}
			}

			return (points, velocities);
		}

		private float3 CalculatePointPosition(int x, int y, int z, int numPerAxis, Vector3 centre, Vector3 size)
		{
			float tX = x / (numPerAxis - 1f);
			float tY = y / (numPerAxis - 1f);
			float tZ = z / (numPerAxis - 1f);

			float pX = (tX - 0.5f) * size.x + centre.x;
			float pY = (tY - 0.5f) * size.y + centre.y;
			float pZ = (tZ - 0.5f) * size.z + centre.z;

			return new float3(pX, pY, pZ);
		}


		private void OnValidate()
		{
			debug_spawn_volume = 0;
			debug_num_particles = 0;

			if (spawnRegions != null)
			{
				foreach (SpawnRegion region in spawnRegions)
				{
					debug_spawn_volume += region.Volume;
					int numPerAxis = region.CalculateParticleCountPerAxis(particleSpawnDensity);
					debug_num_particles += numPerAxis * numPerAxis * numPerAxis;
				}
			}
		}

		private void OnDrawGizmos()
		{
			if (showSpawnBounds && !Application.isPlaying)
			{
				foreach (SpawnRegion region in spawnRegions)
				{
					Gizmos.color = region.debugDisplayCol;
					Gizmos.DrawWireCube(region.centre, Vector3.one * region.size);
				}
			}
		}

		[System.Serializable]
		public struct SpawnRegion
		{
			public Vector3 centre;
			public float size;
			public Color debugDisplayCol;

			public float Volume => size * size * size;

			public int CalculateParticleCountPerAxis(int particleDensity)
			{
				int targetParticleCount = (int)(Volume * particleDensity);
				int particlesPerAxis = (int)Math.Cbrt(targetParticleCount);
				return particlesPerAxis;
			}
		}

		public struct SpawnData
		{
			public float3[] points;
			public float3[] velocities;
		}
	}
}
------------------------------

